# FILENAME: ui/metrology_dashboard_page.py
# (FILENAME: ui/metrology_dashboard_page.py - START)  [PART 1/2]
# -*- coding: utf-8 -*-
"""
BazaS2 (offline) — ui/metrology_dashboard_page.py

Metrologija Dashboard (V1) — PRO DARK UI (polish + row status tint):
- Dark QSS tema (premium)
- KPI kartice iste dimenzije
- Status toggle dugmići ispod KPI (checked glow)
- Chip bar "Aktivni filteri" (sa X)
- Redovi obojeni po statusu (subtle tint) + leva akcent traka
- Status kao badge samo u STATUS ćeliji (jače)
- Sortiranje po kolonama (EditRole)
- Context menu + copy

DODATO (bez menjanja dizajna):
- Prva kolona: "#" (redni broj)
- Drag&drop kolona (samo prikaz): header movable
- Dugme "Kolone: reset" (vraća default redosled + default širine)
- Renumeracija "#": posle sortiranja i posle filtera (uvek 1..N)
"""

from __future__ import annotations

import logging
import sqlite3
from contextlib import contextmanager
from dataclasses import dataclass
from datetime import date
from typing import Any, Dict, List, Tuple

from PySide6.QtCore import Qt, QRect  # type: ignore
from PySide6.QtGui import QColor, QBrush, QPainter  # type: ignore
from PySide6.QtWidgets import (  # type: ignore
    QWidget,
    QHBoxLayout,
    QVBoxLayout,
    QLabel,
    QPushButton,
    QLineEdit,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
    QAbstractItemView,
    QComboBox,
    QCheckBox,
    QFrame,
    QMenu,
    QHeaderView,
    QSizePolicy,
    QToolButton,
    QStyledItemDelegate,
    QStyle,
    QStyleOptionViewItem,
)

# utili (best-effort)
try:
    from ui.utils.datetime_fmt import fmt_dt_sr, fmt_date_sr  # type: ignore
except Exception:  # pragma: no cover
    def fmt_dt_sr(x: str) -> str:
        return (x or "").strip()

    def fmt_date_sr(x: str) -> str:
        return (x or "").strip()

try:
    from ui.utils.table_copy import (  # type: ignore
        wire_table_selection_plus_copy,
        wire_table_header_plus_copy,
        copy_selected_cells,
    )
except Exception:  # pragma: no cover
    wire_table_selection_plus_copy = None
    wire_table_header_plus_copy = None

    def copy_selected_cells(tbl: QTableWidget) -> None:
        return


# -------------------- RBAC helpers (UI-level, fail-closed) --------------------
try:
    from core.rbac import PERM_METRO_VIEW  # type: ignore
except Exception:  # pragma: no cover
    PERM_METRO_VIEW = "metrology.view"


def _can(perm: str) -> bool:
    try:
        from core.session import can  # type: ignore
        return bool(can(perm))
    except Exception:
        return False


def _get_current_user_dict() -> Dict[str, Any]:
    try:
        from core.session import get_current_user  # type: ignore
        return dict(get_current_user() or {})
    except Exception:
        return {}


def _actor_name_safe() -> str:
    try:
        from core.session import actor_name  # type: ignore
        return (actor_name() or "user").strip() or "user"
    except Exception:
        return "user"


def _actor_key_safe() -> str:
    try:
        from core.session import actor_key  # type: ignore
        return (actor_key() or "").strip()
    except Exception:
        return ""


def _norm(s: Any) -> str:
    return ("" if s is None else str(s)).strip().casefold()


def _identity_candidates() -> List[str]:
    u = _get_current_user_dict()
    cand: List[str] = []

    ak = _actor_key_safe()
    if ak:
        cand.append(ak)

    an = _actor_name_safe()
    if an:
        cand.append(an)

    for k in ("username", "login", "email", "display_name", "name", "full_name", "user"):
        v = u.get(k)
        if v:
            cand.append(str(v))

    for k in ("id", "user_id", "uid"):
        v = u.get(k)
        if v is not None and str(v).strip():
            cand.append(str(v).strip())

    out: List[str] = []
    seen = set()
    for c in cand:
        cc = _norm(c)
        if cc and cc not in seen:
            seen.add(cc)
            out.append(cc)
    return out


def _holder_matches_me(holder_value: Any) -> bool:
    h = _norm(holder_value)
    if not h:
        return False
    cands = _identity_candidates()
    for c in cands:
        if h == c:
            return True
    for c in cands:
        if c and (c in h or h in c):
            return True
    return False


def _copy_text_to_clipboard(text: str) -> None:
    try:
        from PySide6.QtWidgets import QApplication  # type: ignore
        QApplication.clipboard().setText(text or "")
    except Exception:
        pass


def _wire_table_copy(table: QTableWidget) -> None:
    # UX: red selection + copy
    try:
        table.setSelectionBehavior(QAbstractItemView.SelectRows)
        table.setSelectionMode(QAbstractItemView.SingleSelection)
    except Exception:
        pass

    try:
        if wire_table_selection_plus_copy is not None:
            wire_table_selection_plus_copy(table)
            return
    except Exception:
        pass

    try:
        if wire_table_header_plus_copy is not None:
            wire_table_header_plus_copy(table)
    except Exception:
        pass


# -------------------- DB helpers --------------------
@contextmanager
def _connect_db():
    try:
        from core.db import db_conn  # type: ignore
        with db_conn() as conn:
            try:
                conn.row_factory = sqlite3.Row
            except Exception:
                pass
            yield conn
            return
    except Exception:
        pass

    conn = sqlite3.connect("data/db/bazas2.sqlite")
    try:
        conn.row_factory = sqlite3.Row
    except Exception:
        pass
    try:
        yield conn
    finally:
        try:
            conn.close()
        except Exception:
            pass


def _table_exists(conn: sqlite3.Connection, name: str) -> bool:
    try:
        r = conn.execute(
            "SELECT 1 FROM sqlite_master WHERE type='table' AND name=? LIMIT 1;",
            (name,),
        ).fetchone()
        return bool(r)
    except Exception:
        return False


def _cols(conn: sqlite3.Connection, table: str) -> List[str]:
    try:
        rows = conn.execute(f"PRAGMA table_info({table});").fetchall()
        out: List[str] = []
        for r in rows:
            try:
                out.append(str(r["name"]))
            except Exception:
                out.append(str(r[1]))
        return out
    except Exception:
        return []


def _pick_col(cols: List[str], candidates: Tuple[str, ...]) -> str:
    s = set(cols or [])
    for c in candidates:
        if c in s:
            return c
    return ""


def _met_status(valid_until_iso: str, warn_days: int) -> str:
    vu = (valid_until_iso or "").strip()
    if not vu:
        return "NEPOZNATO"
    try:
        y, m, d = [int(x) for x in vu.split("-")]
        vu_date = date(y, m, d)
    except Exception:
        return "NEPOZNATO"

    today = date.today()
    if vu_date < today:
        return "ISTEKLO"

    try:
        wd = int(warn_days)
    except Exception:
        wd = 30

    if (vu_date - today).days <= wd:
        return "ISTIČE"
    return "OK"


@dataclass
class MetroDashRow:
    asset_uid: str
    name: str
    category: str
    holder: str
    sector: str
    location: str
    last_assigned_at: str
    met_uid: str
    valid_until: str
    status: str


def _fetch_dashboard_rows(warn_days: int = 30) -> List[MetroDashRow]:
    with _connect_db() as conn:
        if not _table_exists(conn, "assets") or not _table_exists(conn, "metrology_records"):
            return []

        a_cols = _cols(conn, "assets")
        m_cols = _cols(conn, "metrology_records")

        col_uid = _pick_col(a_cols, ("asset_uid", "uid"))
        col_name = _pick_col(a_cols, ("name", "naziv", "asset_name"))
        col_cat = _pick_col(a_cols, ("category", "kategorija", "cat"))
        col_holder = _pick_col(a_cols, ("current_holder", "assigned_to", "holder", "zaduzeno_kod", "kod_koga"))
        col_sector = _pick_col(a_cols, ("sector", "sektor", "org_unit", "unit", "department", "dept"))
        col_loc = _pick_col(a_cols, ("location", "lokacija", "loc"))
        col_assigned_at = _pick_col(a_cols, ("last_assigned_at", "assigned_at", "zaduzeno_od", "assigned_time"))
        col_updated = _pick_col(a_cols, ("updated_at", "modified_at", "updated", "last_update"))

        col_m_asset = _pick_col(m_cols, ("asset_uid",))
        col_m_uid = _pick_col(m_cols, ("met_uid", "uid"))
        col_m_valid = _pick_col(m_cols, ("valid_until",))
        col_m_updated = _pick_col(m_cols, ("updated_at", "modified_at", "updated"))

        if not col_uid or not col_m_asset or not col_m_uid or not col_m_valid:
            return []

        last_time_col = col_assigned_at if col_assigned_at else col_updated

        sql = f"""
        WITH latest_valid AS (
            SELECT
                {col_m_asset} AS asset_uid,
                MAX(date({col_m_valid})) AS max_vu
            FROM metrology_records
            WHERE COALESCE(is_deleted,0)=0
              AND COALESCE({col_m_valid}, '') <> ''
            GROUP BY {col_m_asset}
        ),
        latest_pick AS (
            SELECT
                mr.{col_m_asset} AS asset_uid,
                mr.{col_m_uid} AS met_uid,
                mr.{col_m_valid} AS valid_until,
                COALESCE(mr.{col_m_updated}, '') AS updated_at
            FROM metrology_records mr
            JOIN latest_valid lv
              ON lv.asset_uid = mr.{col_m_asset}
             AND date(mr.{col_m_valid}) = lv.max_vu
            WHERE COALESCE(mr.is_deleted,0)=0
        ),
        latest_one AS (
            SELECT lp.*
            FROM latest_pick lp
            JOIN (
                SELECT asset_uid, MAX(datetime(updated_at)) AS mx
                FROM latest_pick
                GROUP BY asset_uid
            ) t
            ON t.asset_uid = lp.asset_uid AND datetime(lp.updated_at) = t.mx
        )
        SELECT
            a.{col_uid} AS asset_uid,
            COALESCE(a.{col_name}, '') AS name,
            COALESCE(a.{col_cat}, '') AS category,
            COALESCE(a.{col_holder}, '') AS holder,
            COALESCE(a.{col_sector}, '') AS sector,
            COALESCE(a.{col_loc}, '') AS location,
            COALESCE(a.{last_time_col}, '') AS last_assigned_at,
            COALESCE(l.met_uid, '') AS met_uid,
            COALESCE(l.valid_until, '') AS valid_until
        FROM assets a
        LEFT JOIN latest_one l
          ON l.asset_uid = a.{col_uid}
        ;
        """

        try:
            rows = conn.execute(sql).fetchall()
        except Exception:
            return []

        out: List[MetroDashRow] = []
        for r in rows:
            asset_uid = str(r["asset_uid"] or "").strip()
            if not asset_uid:
                continue

            name = str(r["name"] or "").strip()
            category = str(r["category"] or "").strip()
            holder = str(r["holder"] or "").strip()
            sector = str(r["sector"] or "").strip()
            location = str(r["location"] or "").strip()
            last_assigned_at = str(r["last_assigned_at"] or "").strip()
            met_uid = str(r["met_uid"] or "").strip()
            valid_until = str(r["valid_until"] or "").strip()

            st = _met_status(valid_until, warn_days)

            out.append(
                MetroDashRow(
                    asset_uid=asset_uid,
                    name=name,
                    category=category,
                    holder=holder,
                    sector=sector,
                    location=location,
                    last_assigned_at=last_assigned_at,
                    met_uid=met_uid,
                    valid_until=valid_until,
                    status=st,
                )
            )

        order_rank = {"ISTEKLO": 0, "ISTIČE": 1, "OK": 2, "NEPOZNATO": 3}

        def _key(x: MetroDashRow):
            vu = x.valid_until or "9999-12-31"
            return (order_rank.get(x.status, 9), vu, x.asset_uid)

        out.sort(key=_key)
        return out


def _kpi_counts(rows: List[MetroDashRow]) -> Dict[str, int]:
    c = {"ISTEKLO": 0, "ISTIČE": 0, "OK": 0, "NEPOZNATO": 0, "UKUPNO": 0}
    c["UKUPNO"] = len(rows)
    for r in rows:
        if r.status in c:
            c[r.status] += 1
        else:
            c["NEPOZNATO"] += 1
    return c


# -------------------- THEME (PRO DARK) --------------------
DASH_QSS = """
QWidget#MetroDashRoot { background: #12141a; color: #e7e9f1; font-size: 12px; }
QLabel#title { font-size: 20px; font-weight: 900; }

QLineEdit {
  background: #171a22;
  border: 1px solid #2a3040;
  border-radius: 10px;
  padding: 8px 10px;
}
QLineEdit:focus { border: 1px solid #2e6bff; }

QComboBox {
  background: #171a22;
  border: 1px solid #2a3040;
  border-radius: 10px;
  padding: 6px 10px;
}
QComboBox::drop-down { border: 0px; width: 22px; }
QComboBox QAbstractItemView { background: #171a22; border: 1px solid #2a3040; selection-background-color: #24355f; }

QCheckBox { spacing: 8px; color: #d7dbe6; }
QCheckBox::indicator { width: 16px; height: 16px; border-radius: 4px; border: 1px solid #2a3040; background: #171a22; }
QCheckBox::indicator:checked { background: #2e6bff; border: 1px solid #2e6bff; }

QPushButton, QToolButton {
  background: #171a22;
  border: 1px solid #2a3040;
  border-radius: 10px;
  padding: 8px 14px;
}
QPushButton:hover, QToolButton:hover { border: 1px solid #2e6bff; }
QPushButton:pressed, QToolButton:pressed { background: #141724; }
QPushButton:disabled, QToolButton:disabled { color: #7b849c; background: #141724; border: 1px solid #23283a; }

QPushButton#primary {
  background: #2e6bff;
  border: 1px solid #2e6bff;
  color: #ffffff;
  font-weight: 900;
}
QPushButton#primary:hover { background: #255df0; }

QToolButton#StatusBtn {
  padding: 7px 12px;
  border-radius: 12px;
  font-weight: 900;
}
QToolButton#StatusBtn:checked {
  border: 1px solid #3a7bff;
  background: #162547;
}

QToolButton#FocusBtn {
  padding: 7px 12px;
  border-radius: 12px;
  font-weight: 900;
}
QToolButton#FocusBtn:checked {
  border: 1px solid #3a7bff;
  background: #14203b;
}

QFrame#kpiCard {
  background: #161a24;
  border: 1px solid #2a3040;
  border-radius: 14px;
}
QFrame#kpiCard:hover { border: 1px solid #3a7bff; }
QFrame#kpiAccent { border-radius: 3px; }

QFrame#ChipBar {
  background: #131726;
  border: 1px solid #232a3a;
  border-radius: 12px;
}
QPushButton#ChipX {
  padding: 2px 7px;
  border-radius: 9px;
  font-weight: 900;
  background: #1a1f2f;
  border: 1px solid #2a3040;
}
QPushButton#ChipX:hover { border: 1px solid #3a7bff; }

QTableWidget {
  background: #121624;
  border: 1px solid #2a3040;
  border-radius: 12px;
  gridline-color: #2b3346;
  alternate-background-color: #111a2a;
  selection-background-color: #223a66;
  selection-color: #ffffff;
}
QTableWidget::item {
  padding: 7px 10px;
  border-bottom: 1px solid #1d2434;
  border-right: 1px solid #1d2434;
  color: #d7dbe6;
}
QTableWidget::item:hover { background: #172544; }
QTableWidget::item:selected { background: #223a66; color: #ffffff; }

QHeaderView::section {
  background: #171a22;
  color: #dfe3ee;
  border: 0px;
  border-bottom: 2px solid #2b3346;
  border-right: 1px solid #2b3346;
  padding: 10px 10px;
  font-weight: 900;
}

QScrollBar:vertical {
  background: #0f1116;
  width: 12px;
  margin: 8px 2px 8px 2px;
  border-radius: 6px;
}
QScrollBar::handle:vertical {
  background: #2a3040;
  min-height: 30px;
  border-radius: 6px;
}
QScrollBar::handle:vertical:hover { background: #3a4460; }
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }

QScrollBar:horizontal {
  background: #0f1116;
  height: 12px;
  margin: 2px 8px 2px 8px;
  border-radius: 6px;
}
QScrollBar::handle:horizontal {
  background: #2a3040;
  min-width: 30px;
  border-radius: 6px;
}
QScrollBar::handle:horizontal:hover { background: #3a4460; }
QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal { width: 0px; }
"""


class _KpiCard(QFrame):
    def __init__(self, title: str, accent_color: str, parent=None):
        super().__init__(parent)
        self.setObjectName("kpiCard")
        self.setFixedSize(190, 74)  # ✅ iste dimenzije

        lay = QHBoxLayout(self)
        lay.setContentsMargins(12, 12, 12, 12)
        lay.setSpacing(10)

        self.accent = QFrame()
        self.accent.setObjectName("kpiAccent")
        self.accent.setFixedWidth(6)
        self.accent.setStyleSheet(f"QFrame#kpiAccent {{ background: {accent_color}; }}")

        right = QVBoxLayout()
        right.setContentsMargins(0, 0, 0, 0)
        right.setSpacing(2)

        self.lb_title = QLabel(title)
        self.lb_title.setStyleSheet("font-size: 12px; color: #aab2c5; font-weight: 800;")

        self.lb_value = QLabel("0")
        self.lb_value.setStyleSheet("font-size: 24px; font-weight: 950; color: #ffffff;")

        right.addWidget(self.lb_title)
        right.addWidget(self.lb_value, 1)

        lay.addWidget(self.accent)
        lay.addLayout(right, 1)

    def set_value(self, v: int) -> None:
        try:
            self.lb_value.setText(str(int(v)))
        except Exception:
            self.lb_value.setText("0")


def _set_sort_data(item: QTableWidgetItem, sort_value: Any) -> None:
    try:
        item.setData(Qt.EditRole, sort_value)
    except Exception:
        pass


def _status_badge_style(item: QTableWidgetItem, status: str) -> None:
    st = (status or "").strip().upper()

    if st == "ISTEKLO":
        item.setBackground(QBrush(QColor("#2a1214")))
        item.setForeground(QBrush(QColor("#ffd0d4")))
    elif st in ("ISTIČE", "ISTICE"):
        item.setBackground(QBrush(QColor("#2a2412")))
        item.setForeground(QBrush(QColor("#ffe8b8")))
    elif st == "OK":
        item.setBackground(QBrush(QColor("#102417")))
        item.setForeground(QBrush(QColor("#c8f7d6")))
    else:
        item.setBackground(QBrush(QColor("#171923")))
        item.setForeground(QBrush(QColor("#d7dbe6")))

    f = item.font()
    f.setBold(True)
    item.setFont(f)


# -------------------- Row tint delegate (status -> row background + accent stripe) --------------------
class _RowStatusTintDelegate(QStyledItemDelegate):
    """
    Delegate koji boji CE0 RED po statusu (subtle tint), i crta levu akcent traku.
    STATUS kolonu ne farbamo tint-om (da badge ostane jak).
    """

    def __init__(self, table: QTableWidget, status_col: int = 0, accent_px: int = 3):
        super().__init__(table)
        self._tbl = table
        self._status_col = int(status_col)
        self._accent_px = int(accent_px)

        # (accent, tint) boje — namerno "prijatne"
        self._palette = {
            "ISTEKLO": (QColor("#ff4d57"), QColor("#241417")),
            "ISTIČE": (QColor("#ffcc00"), QColor("#232013")),
            "ISTICE": (QColor("#ffcc00"), QColor("#232013")),
            "OK": (QColor("#22c55e"), QColor("#142418")),
            "NEPOZNATO": (QColor("#a0a6b6"), QColor("#171a22")),
        }

    def _status_for_row(self, row: int) -> str:
        try:
            it = self._tbl.item(row, self._status_col)
            st = (it.text() if it else "") or ""
            st = st.strip().upper()
            return st if st else "NEPOZNATO"
        except Exception:
            return "NEPOZNATO"

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index) -> None:
        try:
            row = int(index.row())
            col = int(index.column())
        except Exception:
            super().paint(painter, option, index)
            return

        st = self._status_for_row(row)
        accent, tint = self._palette.get(st, self._palette["NEPOZNATO"])

        is_selected = bool(option.state & QStyle.State_Selected)

        painter.save()

        # tint background for non-status columns when NOT selected
        if (col != self._status_col) and (not is_selected):
            painter.fillRect(option.rect, tint)

        # left accent stripe (only on first visible column)
        if col == 0:
            r = QRect(option.rect)
            stripe = QRect(r.left(), r.top(), self._accent_px, r.height())
            painter.fillRect(stripe, accent)

        painter.restore()
        super().paint(painter, option, index)


# -------------------- Chip helpers --------------------
class _Chip(QFrame):
    def __init__(self, text: str, on_close, parent=None):
        super().__init__(parent)
        self.setObjectName("ChipBar")
        self.setStyleSheet("QFrame#ChipBar{padding:0px;}")  # bar style is on container, chip is custom below

        lay = QHBoxLayout(self)
        lay.setContentsMargins(10, 6, 10, 6)
        lay.setSpacing(8)

        self.lb = QLabel(text)
        self.lb.setStyleSheet("color:#dfe3ee; font-weight:800;")
        lay.addWidget(self.lb)

        self.x = QPushButton("×")
        self.x.setObjectName("ChipX")
        self.x.setFixedSize(24, 22)
        self.x.clicked.connect(on_close)
        lay.addWidget(self.x)

        self.setStyleSheet("""
        QFrame {
          background:#141a2a;
          border: 1px solid #232a3a;
          border-radius: 12px;
        }
        """)


class MetrologyDashboardPage(QWidget):
    # ✅ DODATO: prva kolona "#"
    COLS = [
        "#",
        "Status", "Važi do", "Met UID",
        "UID", "Naziv", "Kategorija",
        "Nosilac", "Sektor", "Lokacija", "Zaduženo od",
    ]

    # ✅ indeksi kolona
    C_NO = 0
    C_STATUS = 1
    C_VALID_UNTIL = 2
    C_MET_UID = 3
    C_UID = 4
    C_NAME = 5
    C_CAT = 6
    C_HOLDER = 7
    C_SECTOR = 8
    C_LOC = 9
    C_ASSIGNED = 10

    def __init__(self, logger: logging.Logger, parent=None):
        super().__init__(parent)
        self.setObjectName("MetroDashRoot")
        self.setStyleSheet(DASH_QSS)

        self.logger = logger
        self._rows: List[MetroDashRow] = []

        # ✅ za reset kolona
        self._default_visual_order: List[int] = []
        self._default_col_widths: Dict[int, int] = {}
        self._renumber_guard = False

        # --- Header row ---
        top = QHBoxLayout()
        top.setContentsMargins(0, 0, 0, 0)
        top.setSpacing(10)

        title = QLabel("Metrologija Dashboard")
        title.setObjectName("title")
        top.addWidget(title)
        top.addStretch(1)

        self.ed_search = QLineEdit()
        self.ed_search.setPlaceholderText("Pretraga (UID / naziv / nosilac / sektor / status)...")
        self.ed_search.setClearButtonEnabled(True)
        self.ed_search.setFixedWidth(520)
        top.addWidget(self.ed_search)

        self.lbl_warn = QLabel("Alarm (dana):")
        self.lbl_warn.setStyleSheet("color:#aab2c5; font-weight:700;")
        self.cb_warn = QComboBox()
        self.cb_warn.addItems(["7", "14", "30", "60", "90"])
        self.cb_warn.setCurrentText("30")
        self.cb_warn.setFixedWidth(90)
        top.addWidget(self.lbl_warn)
        top.addWidget(self.cb_warn)

        self.btn_refresh = QPushButton("Osveži")
        self.btn_refresh.setObjectName("primary")
        self.btn_refresh.setFixedWidth(120)
        top.addWidget(self.btn_refresh)

        # --- KPI row ---
        kpi = QHBoxLayout()
        kpi.setSpacing(12)

        self.kpi_overdue = _KpiCard("Isteklo", "#ff4d57")
        self.kpi_due = _KpiCard("Ističe uskoro", "#ffcc00")
        self.kpi_ok = _KpiCard("Validno", "#22c55e")
        self.kpi_total = _KpiCard("Ukupno", "#3b82f6")

        kpi.addWidget(self.kpi_overdue)
        kpi.addWidget(self.kpi_due)
        kpi.addWidget(self.kpi_ok)
        kpi.addWidget(self.kpi_total)
        kpi.addStretch(1)

        # --- Status toggles row (ispod dashboarda / KPI) ---
        status_row = QHBoxLayout()
        status_row.setSpacing(10)

        self.btn_st_overdue = self._mk_status_btn("Isteklo", "#ff4d57")
        self.btn_st_due = self._mk_status_btn("Ističe", "#ffcc00")
        self.btn_st_ok = self._mk_status_btn("OK", "#22c55e")
        self.btn_st_unknown = self._mk_status_btn("Nepoznato", "#a0a6b6")

        for b in (self.btn_st_overdue, self.btn_st_due, self.btn_st_ok, self.btn_st_unknown):
            b.setChecked(True)

        self.btn_focus = QToolButton()
        self.btn_focus.setObjectName("FocusBtn")
        self.btn_focus.setText("Fokus: samo kritično")
        self.btn_focus.setCheckable(True)
        self.btn_focus.setToolTip("Uključi Isteklo+Ističe, sakrij OK/Nepoznato.")

        status_row.addWidget(QLabel("Status filteri:"))
        status_row.addWidget(self.btn_st_overdue)
        status_row.addWidget(self.btn_st_due)
        status_row.addWidget(self.btn_st_ok)
        status_row.addWidget(self.btn_st_unknown)
        status_row.addSpacing(10)
        status_row.addWidget(self.btn_focus)
        status_row.addStretch(1)

        # --- Other filters + actions row ---
        flt = QHBoxLayout()
        flt.setSpacing(14)

        self.ck_my = QCheckBox("Samo moja sredstva")
        flt.addWidget(self.ck_my)

        # ✅ DODATO: "Kolone: reset" (bez menjanja dizajna)
        self.btn_cols_reset = QPushButton("Kolone: reset")
        self.btn_cols_reset.setToolTip("Vrati default raspored i širine kolona.")
        flt.addWidget(self.btn_cols_reset)

        flt.addStretch(1)

        self.btn_open_asset = QPushButton("Otvori sredstvo")
        self.btn_open_asset.setEnabled(False)
        flt.addWidget(self.btn_open_asset)

        self.btn_open_met_list = QPushButton("Otvori metrologiju (lista)")
        self.btn_open_met_list.setEnabled(False)
        flt.addWidget(self.btn_open_met_list)

        # --- Active filters chip bar ---
        self.chip_wrap = QFrame()
        self.chip_wrap.setObjectName("ChipBar")
        self.chip_wrap.setStyleSheet("""
        QFrame#ChipBar{
          background:#131726;
          border: 1px solid #232a3a;
          border-radius: 12px;
        }
        """)
        self.chip_lay = QHBoxLayout(self.chip_wrap)
        self.chip_lay.setContentsMargins(10, 8, 10, 8)
        self.chip_lay.setSpacing(8)

        self.lb_chips_title = QLabel("Aktivni filteri:")
        self.lb_chips_title.setStyleSheet("color:#aab2c5; font-weight:900;")
        self.chip_lay.addWidget(self.lb_chips_title)

        self.chip_lay.addStretch(1)
        self.chip_wrap.setVisible(False)

        # --- Separator ---
        sep = QFrame()
        sep.setFrameShape(QFrame.HLine)
        sep.setStyleSheet("color: #2a3040;")

        # --- Table ---
        self.tbl = QTableWidget(0, len(self.COLS))
        self.tbl.setHorizontalHeaderLabels(self.COLS)
        self.tbl.setEditTriggers(QTableWidget.NoEditTriggers)
        self.tbl.setAlternatingRowColors(True)
        self.tbl.setShowGrid(True)
        self.tbl.setGridStyle(Qt.SolidLine)
        self.tbl.verticalHeader().setVisible(False)

        self.tbl.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tbl.setSelectionMode(QAbstractItemView.SingleSelection)
        self.tbl.setSortingEnabled(True)

        try:
            self.tbl.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
            self.tbl.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
        except Exception:
            pass

        hdr = self.tbl.horizontalHeader()
        hdr.setDefaultAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        hdr.setFixedHeight(38)
        hdr.setSectionResizeMode(QHeaderView.Interactive)
        hdr.setStretchLastSection(True)

        # ✅ DODATO: drag&drop kolona (samo prikaz)
        hdr.setSectionsMovable(True)
        hdr.setSectionsClickable(True)

        # ✅ posle sortiranja: renumeriši "#"
        hdr.sortIndicatorChanged.connect(self._renumber_rows)

        self.tbl.verticalHeader().setDefaultSectionSize(32)

        # widths (tvoje, samo dodato za "#")
        self.tbl.setColumnWidth(self.C_NO, 52)
        self.tbl.setColumnWidth(self.C_STATUS, 120)
        self.tbl.setColumnWidth(self.C_VALID_UNTIL, 110)
        self.tbl.setColumnWidth(self.C_MET_UID, 180)
        self.tbl.setColumnWidth(self.C_UID, 150)
        self.tbl.setColumnWidth(self.C_NAME, 320)
        self.tbl.setColumnWidth(self.C_CAT, 120)
        self.tbl.setColumnWidth(self.C_HOLDER, 160)
        self.tbl.setColumnWidth(self.C_SECTOR, 90)
        self.tbl.setColumnWidth(self.C_LOC, 140)
        self.tbl.setColumnWidth(self.C_ASSIGNED, 160)

        _wire_table_copy(self.tbl)

        # ✅ delegate: row tint + accent stripe
        # status_col se pomera jer sada postoji "#" kolona
        self.tbl.setItemDelegate(_RowStatusTintDelegate(self.tbl, status_col=self.C_STATUS, accent_px=3))

        self.tbl.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tbl.customContextMenuRequested.connect(self._on_context_menu)
        self.tbl.itemSelectionChanged.connect(self._sync_buttons)
        self.tbl.cellDoubleClicked.connect(self._on_double_click)

        # --- RBAC label ---
        self.lb_rbac = QLabel("")
        self.lb_rbac.setStyleSheet("color: #ff7b7b; font-weight: 800;")
        self.lb_rbac.setVisible(False)
        self.lb_rbac.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # --- Layout ---
        main = QVBoxLayout(self)
        main.setContentsMargins(16, 14, 16, 16)
        main.setSpacing(12)
        main.addLayout(top)
        main.addLayout(kpi)
        main.addLayout(status_row)   # ispod KPI
        main.addLayout(flt)
        main.addWidget(self.chip_wrap)
        main.addWidget(sep)
        main.addWidget(self.lb_rbac)
        main.addWidget(self.tbl, 1)

        # ✅ snapshot default kolona (redosled + širine)
        self._capture_default_columns()

        # --- Signals ---
        self.btn_refresh.clicked.connect(self.refresh)
        self.ed_search.textChanged.connect(self._apply_filter)
        self.cb_warn.currentIndexChanged.connect(self._apply_filter)
        self.ck_my.stateChanged.connect(self._apply_filter)

        for b in (self.btn_st_overdue, self.btn_st_due, self.btn_st_ok, self.btn_st_unknown):
            b.toggled.connect(self._on_status_toggle)

        self.btn_focus.toggled.connect(self._on_focus_toggle)

        self.btn_cols_reset.clicked.connect(self._reset_columns_default)

        self.btn_open_asset.clicked.connect(self._open_asset)
        self.btn_open_met_list.clicked.connect(self._open_metrology_list)

        self._apply_rbac()
        self.refresh()

    # -------------------- UI builders --------------------
    def _mk_status_btn(self, text: str, color_hex: str) -> QToolButton:
        b = QToolButton()
        b.setObjectName("StatusBtn")
        b.setText(text)
        b.setCheckable(True)
        b.setToolButtonStyle(Qt.ToolButtonTextOnly)
        b.setStyleSheet(f"""
        QToolButton#StatusBtn {{
          border: 1px solid #2a3040;
        }}
        QToolButton#StatusBtn:checked {{
          border: 1px solid {color_hex};
          background: rgba(46,107,255,0.18);
        }}
        """)
        return b

    # -------------------- columns reset helpers --------------------
    def _capture_default_columns(self) -> None:
        """Snimi default vizuelni raspored i širine kolona (za reset)."""
        try:
            hdr = self.tbl.horizontalHeader()
            n = self.tbl.columnCount()
            self._default_visual_order = [hdr.visualIndex(i) for i in range(n)]
            self._default_col_widths = {i: int(self.tbl.columnWidth(i)) for i in range(n)}
        except Exception:
            self._default_visual_order = []
            self._default_col_widths = {}

    def _reset_columns_default(self) -> None:
        """Vrati default redosled kolona + default širine. (Samo prikaz, ne dira sadržaj)"""
        try:
            hdr = self.tbl.horizontalHeader()
            n = self.tbl.columnCount()
            if not self._default_visual_order or len(self._default_visual_order) != n:
                self._capture_default_columns()

            # vratiti redosled: željeni vizuelni indeks za svaku logičku kolonu
            # self._default_visual_order[logical] = visual_at_default
            # -> za svaku logičku kolonu: pomeri je na njen default visual index
            hdr.blockSignals(True)
            self.tbl.setUpdatesEnabled(False)

            # pravimo mapu: default_visual_pos -> logical_col
            pos_to_logical: Dict[int, int] = {}
            for logical_col, visual_pos in enumerate(self._default_visual_order):
                pos_to_logical[int(visual_pos)] = int(logical_col)

            # sada prolazimo po vizuelnim pozicijama 0..n-1 i dovođimo kolonu koja tu treba da bude
            for target_visual in range(n):
                logical_should_be_here = pos_to_logical.get(target_visual)
                if logical_should_be_here is None:
                    continue
                current_visual = hdr.visualIndex(logical_should_be_here)
                if current_visual != target_visual:
                    hdr.moveSection(current_visual, target_visual)

            # vrati širine
            for logical_col, w in (self._default_col_widths or {}).items():
                try:
                    self.tbl.setColumnWidth(int(logical_col), int(w))
                except Exception:
                    pass

        finally:
            try:
                hdr.blockSignals(False)
                self.tbl.setUpdatesEnabled(True)
                # renumeriši posle reset-a, čisto da bude konzistentno
                self._renumber_rows()
            except Exception:
                pass

    # -------------------- RBAC --------------------
    def _apply_rbac(self) -> None:
        ok = _can(PERM_METRO_VIEW)
        for w in (
            self.tbl, self.ed_search, self.cb_warn, self.ck_my, self.btn_refresh,
            self.btn_st_overdue, self.btn_st_due, self.btn_st_ok, self.btn_st_unknown, self.btn_focus,
            self.btn_cols_reset
        ):
            try:
                w.setEnabled(ok)
            except Exception:
                pass

        if not ok:
            self.tbl.setRowCount(0)
            self.lb_rbac.setText("RBAC: nemaš pravo da vidiš metrologija dashboard (metrology.view).")
            self.lb_rbac.setVisible(True)
        else:
            self.lb_rbac.setVisible(False)

    # -------------------- state helpers --------------------
    def _warn_days(self) -> int:
        try:
            return int(self.cb_warn.currentText())
        except Exception:
            return 30

    def _selected_asset_uid(self) -> str:
        r = self.tbl.currentRow()
        if r < 0:
            return ""
        it = self.tbl.item(r, self.C_UID)
        return it.text().strip() if it else ""

    def _selected_met_uid(self) -> str:
        r = self.tbl.currentRow()
        if r < 0:
            return ""
        it = self.tbl.item(r, self.C_MET_UID)
        return it.text().strip() if it else ""

    def _sync_buttons(self) -> None:
        has = self.tbl.currentRow() >= 0
        self.btn_open_asset.setEnabled(has)
        self.btn_open_met_list.setEnabled(has)

    def _enabled_statuses(self) -> set[str]:
        st = set()
        if self.btn_st_overdue.isChecked():
            st.add("ISTEKLO")
        if self.btn_st_due.isChecked():
            st.add("ISTIČE")
            st.add("ISTICE")
        if self.btn_st_ok.isChecked():
            st.add("OK")
        if self.btn_st_unknown.isChecked():
            st.add("NEPOZNATO")
        return st

    def _on_focus_toggle(self, checked: bool) -> None:
        if checked:
            self.btn_st_overdue.blockSignals(True)
            self.btn_st_due.blockSignals(True)
            self.btn_st_ok.blockSignals(True)
            self.btn_st_unknown.blockSignals(True)

            self.btn_st_overdue.setChecked(True)
            self.btn_st_due.setChecked(True)
            self.btn_st_ok.setChecked(False)
            self.btn_st_unknown.setChecked(False)

            self.btn_st_overdue.blockSignals(False)
            self.btn_st_due.blockSignals(False)
            self.btn_st_ok.blockSignals(False)
            self.btn_st_unknown.blockSignals(False)

        self._apply_filter()

    def _on_status_toggle(self, _checked: bool) -> None:
        if self.btn_focus.isChecked():
            crit = self.btn_st_overdue.isChecked() and self.btn_st_due.isChecked() and (not self.btn_st_ok.isChecked()) and (not self.btn_st_unknown.isChecked())
            if not crit:
                self.btn_focus.blockSignals(True)
                self.btn_focus.setChecked(False)
                self.btn_focus.blockSignals(False)
        self._apply_filter()

    # -------------------- data load --------------------
    def refresh(self) -> None:
        self._apply_rbac()
        if not _can(PERM_METRO_VIEW):
            return

        try:
            self._rows = _fetch_dashboard_rows(warn_days=self._warn_days())
        except Exception as e:
            self._rows = []
            QMessageBox.critical(self, "Greška", f"Ne mogu da učitam dashboard.\n\n{e}")
            return

        c = _kpi_counts(self._rows)
        self.kpi_overdue.set_value(c.get("ISTEKLO", 0))
        self.kpi_due.set_value(c.get("ISTIČE", 0))
        self.kpi_ok.set_value(c.get("OK", 0))
        self.kpi_total.set_value(c.get("UKUPNO", 0))

        self._apply_filter()

# (FILENAME: ui/metrology_dashboard_page.py - END)  [PART 1/2]

# FILENAME: ui/metrology_dashboard_page.py
# (FILENAME: ui/metrology_dashboard_page.py - START)  [PART 2/2]
    # -------------------- filtering + chips --------------------
    def _apply_filter(self) -> None:
        if not _can(PERM_METRO_VIEW):
            return

        warn_days = self._warn_days()
        q = (self.ed_search.text() or "").strip().casefold()
        only_my = bool(self.ck_my.isChecked())
        enabled_statuses = self._enabled_statuses()

        rows: List[MetroDashRow] = []
        for r in (self._rows or []):
            st = _met_status(r.valid_until, warn_days)
            rr = MetroDashRow(**{**r.__dict__, "status": st})

            st_key = (rr.status or "").strip().upper() or "NEPOZNATO"
            if st_key not in enabled_statuses:
                continue

            if only_my and not _holder_matches_me(rr.holder):
                continue

            if q:
                hay = " ".join([
                    rr.asset_uid, rr.name, rr.category,
                    rr.holder, rr.sector, rr.location,
                    rr.status, rr.met_uid, rr.valid_until, rr.last_assigned_at
                ]).casefold()
                if q not in hay:
                    continue

            rows.append(rr)

        self._render(rows)
        self._refresh_chips()
        # ✅ posle filtera uvek renumeriši "#"
        self._renumber_rows()

    def _clear_chip_row(self) -> None:
        while self.chip_lay.count() > 2:
            item = self.chip_lay.takeAt(1)
            w = item.widget()
            if w is not None:
                w.deleteLater()

    def _refresh_chips(self) -> None:
        self._clear_chip_row()

        chips: List[Tuple[str, Any]] = []

        if not (self.btn_st_overdue.isChecked() and self.btn_st_due.isChecked() and self.btn_st_ok.isChecked() and self.btn_st_unknown.isChecked()):
            if self.btn_st_overdue.isChecked():
                chips.append(("Isteklo", lambda: self.btn_st_overdue.setChecked(False)))
            if self.btn_st_due.isChecked():
                chips.append(("Ističe", lambda: self.btn_st_due.setChecked(False)))
            if self.btn_st_ok.isChecked():
                chips.append(("OK", lambda: self.btn_st_ok.setChecked(False)))
            if self.btn_st_unknown.isChecked():
                chips.append(("Nepoznato", lambda: self.btn_st_unknown.setChecked(False)))

        if self.btn_focus.isChecked():
            chips.append(("Fokus: kritično", lambda: self.btn_focus.setChecked(False)))

        if self.ck_my.isChecked():
            chips.append(("Samo moja", lambda: self.ck_my.setChecked(False)))

        if (self.ed_search.text() or "").strip():
            chips.append((f'Pretraga: "{(self.ed_search.text() or "").strip()}"', lambda: self.ed_search.setText("")))

        wd = self._warn_days()
        if wd != 30:
            chips.append((f"Alarm: {wd} dana", lambda: self.cb_warn.setCurrentText("30")))

        for text, fn in chips:
            self.chip_lay.insertWidget(self.chip_lay.count() - 1, _Chip(text, fn, self.chip_wrap))

        self.chip_wrap.setVisible(len(chips) > 0)

    # -------------------- rendering --------------------
    def _render(self, rows: List[MetroDashRow]) -> None:
        try:
            self.tbl.setSortingEnabled(False)
            self.tbl.setUpdatesEnabled(False)
            self.tbl.setRowCount(0)

            for rr in rows:
                i = self.tbl.rowCount()
                self.tbl.insertRow(i)

                base_bg = QBrush(QColor("#121624" if (i % 2 == 0) else "#111a2a"))

                # ✅ DODATO: "#" prva kolona
                vals = [
                    str(i + 1),  # "#"
                    rr.status,
                    fmt_date_sr(rr.valid_until or ""),
                    rr.met_uid,
                    rr.asset_uid,
                    rr.name,
                    rr.category,
                    rr.holder,
                    rr.sector,
                    rr.location,
                    fmt_dt_sr(rr.last_assigned_at or ""),
                ]

                for cc, v in enumerate(vals):
                    item = QTableWidgetItem(str(v))

                    # zebra base (delegate će dodati tint preko reda za non-status)
                    item.setBackground(base_bg)

                    # alignment
                    if cc in (self.C_NO, self.C_STATUS, self.C_VALID_UNTIL, self.C_MET_UID, self.C_UID, self.C_SECTOR, self.C_LOC, self.C_ASSIGNED):
                        item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
                    else:
                        item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)

                    # sort keys
                    if cc == self.C_NO:
                        # "#": numeric sort (ali renumeriše se posle svakog sort/filter)
                        try:
                            _set_sort_data(item, int(i + 1))
                        except Exception:
                            _set_sort_data(item, str(i + 1))
                    elif cc == self.C_STATUS:
                        _status_badge_style(item, rr.status)
                        _set_sort_data(item, (rr.status or "").strip().upper() or "NEPOZNATO")
                    elif cc == self.C_VALID_UNTIL:
                        _set_sort_data(item, rr.valid_until or "9999-12-31")
                    elif cc == self.C_ASSIGNED:
                        _set_sort_data(item, rr.last_assigned_at or "")
                    else:
                        _set_sort_data(item, str(v))

                    self.tbl.setItem(i, cc, item)

        finally:
            try:
                self.tbl.setUpdatesEnabled(True)
                self.tbl.setSortingEnabled(True)
            except Exception:
                pass

        self._sync_buttons()
        # ✅ posle rendera uvek renumeriši "#"
        self._renumber_rows()

    def _renumber_rows(self, *_args) -> None:
        """Renumeriši '#': uvek 1..N u trenutnom prikazu (posle filtera i posle sortiranja)."""
        if self._renumber_guard:
            return
        self._renumber_guard = True
        try:
            # isključi sorting da ne izazove “ping-pong”
            self.tbl.setSortingEnabled(False)
            for r in range(self.tbl.rowCount()):
                it = self.tbl.item(r, self.C_NO)
                if it is None:
                    it = QTableWidgetItem("")
                    self.tbl.setItem(r, self.C_NO, it)
                it.setText(str(r + 1))
                it.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
                try:
                    _set_sort_data(it, int(r + 1))
                except Exception:
                    _set_sort_data(it, str(r + 1))
            self.tbl.setSortingEnabled(True)
        finally:
            self._renumber_guard = False

    # -------------------- actions --------------------
    def _open_asset(self) -> None:
        asset_uid = self._selected_asset_uid()
        if not asset_uid:
            return
        try:
            from ui.asset_detail_dialog import AssetDetailDialog  # type: ignore
            dlg = AssetDetailDialog(asset_uid, self)
            dlg.exec()
        except Exception as e:
            QMessageBox.information(self, "Info", f"Ne mogu da otvorim detalje sredstva.\n\n{e}")

    def _open_metrology_details(self) -> None:
        met_uid = self._selected_met_uid()
        if not met_uid:
            QMessageBox.information(self, "Info", "Nema metrologija zapisa (met_uid je prazan).")
            return
        try:
            from ui.metrology_page import MetrologyDetailsDialog  # type: ignore
            dlg = MetrologyDetailsDialog(met_uid, parent=self, warn_days=self._warn_days())
            dlg.exec()
        except Exception as e:
            QMessageBox.information(self, "Info", f"Ne mogu da otvorim detalje metrologije.\n\n{e}")

    def _open_metrology_list(self) -> None:
        asset_uid = self._selected_asset_uid()
        if not asset_uid:
            return
        try:
            from ui.my_assets_page import MetrologyForAssetDialog  # type: ignore
            dlg = MetrologyForAssetDialog(asset_uid, warn_days=self._warn_days(), parent=self)
            dlg.exec()
        except Exception as e:
            QMessageBox.information(self, "Info", f"Ne mogu da otvorim listu metrologije.\n\n{e}")

    def _on_double_click(self, r: int, c: int) -> None:
        # status/valid/met_uid kolone (sa pomerenim indeksima)
        if c in (self.C_STATUS, self.C_VALID_UNTIL, self.C_MET_UID):
            if self._selected_met_uid():
                self._open_metrology_details()
            else:
                self._open_metrology_list()
            return
        self._open_asset()

    def _on_context_menu(self, pos) -> None:
        try:
            it = self.tbl.itemAt(pos)
            if it is not None:
                self.tbl.setCurrentCell(it.row(), it.column())

            cur = self.tbl.currentItem()
            cell_text = cur.text() if cur else ""

            uid = self._selected_asset_uid()
            met_uid = self._selected_met_uid()

            menu = QMenu(self)
            act_copy_cell = menu.addAction("Kopiraj ćeliju")
            act_copy_sel = menu.addAction("Kopiraj selekciju (TSV)")
            menu.addSeparator()

            act_copy_uid = menu.addAction("Kopiraj Asset UID") if uid else None
            act_copy_met = menu.addAction("Kopiraj Met UID") if met_uid else None

            menu.addSeparator()
            act_open_asset = menu.addAction("Otvori sredstvo") if uid else None
            act_open_met_details = menu.addAction("Otvori metrologiju (detalji)") if met_uid else None
            act_open_met_list = menu.addAction("Otvori metrologiju (lista)") if uid else None

            chosen = menu.exec(self.tbl.viewport().mapToGlobal(pos))
            if chosen == act_copy_cell:
                _copy_text_to_clipboard(cell_text)
            elif chosen == act_copy_sel:
                copy_selected_cells(self.tbl)
            elif act_copy_uid is not None and chosen == act_copy_uid:
                _copy_text_to_clipboard(uid)
            elif act_copy_met is not None and chosen == act_copy_met:
                _copy_text_to_clipboard(met_uid)
            elif act_open_asset is not None and chosen == act_open_asset:
                self._open_asset()
            elif act_open_met_details is not None and chosen == act_open_met_details:
                self._open_metrology_details()
            elif act_open_met_list is not None and chosen == act_open_met_list:
                self._open_metrology_list()
        except Exception:
            pass

# (FILENAME: ui/metrology_dashboard_page.py - END)  [PART 2/2]