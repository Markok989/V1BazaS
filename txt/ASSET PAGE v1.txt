ASSET PAGE 


# FILENAME: ui/assets_page.py
# (FILENAME: ui/assets_page.py - START)  [PART 1/3]
# -*- coding: utf-8 -*-
"""
BazaS2 (offline) — ui/assets_page.py

Sredstva — UI:
- Tabovi: Aktivna / Bez zaduženja / Rashodovana / Sva
- Lista sredstava + filteri + brzi filter
- Kreiraj novo sredstvo
- Detalji sredstva (AssetDetailDialog)

Dodatno (V1+):
- Preview panel (collapse/expand) sa animacijom
- Numeričko sortiranje (TOC, NOM) preko Qt.UserRole

Polish + Best-practice revizija (bez menjanja osnovne logike):
- Row tint + accent traka levo (delegate, selection-aware) — kao Metrology Dashboard
- Uklonjeno ručno farbanje svake ćelije (brže, stabilnije)
- Robusnije prepoznavanje "rashod/otpis/retired" kao scrapped
- Lokalni filter kategorije tolerantniji na varijacije teksta
- Fail-safe importi za pomoćne util module (UI ne puca)
"""

from __future__ import annotations

import logging
from typing import Dict, Optional, List, Any, Tuple, Callable

from PySide6.QtCore import Qt, QTimer, QSize, QVariantAnimation, QEasingCurve, QRect  # type: ignore
from PySide6.QtGui import QColor, QBrush, QCursor, QPainter  # type: ignore
from PySide6.QtWidgets import (  # type: ignore
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QComboBox,
    QPushButton, QTableWidget, QTableWidgetItem, QMessageBox,
    QAbstractItemView, QTabWidget, QDialog, QSplitter, QFrame,
    QFormLayout, QApplication, QToolButton, QStyle, QHeaderView,
    QStyledItemDelegate, QStyleOptionViewItem,
)

from core.rbac import (
    PERM_ASSETS_VIEW,
    PERM_ASSETS_CREATE,
    PERM_ASSETS_MY_VIEW,
    PERM_ASSETS_METRO_VIEW,
)

from services.assets_service import create_asset, list_assets, list_assets_brief
from ui.asset_detail_dialog import AssetDetailDialog
from ui.new_asset_dialog import NewAssetDialog
from ui.columns_dialog import ColSpec


# ---- fmt_dt_sr (fail-safe) ----
try:
    from ui.utils.datetime_fmt import fmt_dt_sr  # type: ignore
except Exception:  # pragma: no cover
    def fmt_dt_sr(x: Any) -> str:
        return str(x or "").strip()


# ---- wire_columns (fail-safe) ----
try:
    from ui.utils.table_columns import wire_columns  # type: ignore
except Exception:  # pragma: no cover
    wire_columns = None  # type: ignore


# ---- copy helper (fail-safe) ----
try:
    from ui.utils.table_copy import wire_table_selection_plus_copy  # type: ignore
except Exception:  # pragma: no cover
    wire_table_selection_plus_copy = None  # type: ignore


# ---- quick tools (fail-safe) ----
try:
    from ui.utils.table_search_sort import TableToolsBar, TableToolsConfig  # type: ignore
except Exception:  # pragma: no cover
    TableToolsBar = None  # type: ignore
    TableToolsConfig = None  # type: ignore


# -------------------- sortable item (numeričko sortiranje) --------------------
class SortableItem(QTableWidgetItem):
    """
    QTableWidgetItem sort bugfix:
    - Default sort je leksikografski (string).
    - Mi guramo sort ključ u Qt.UserRole i poredimo po njemu kad postoji.
    """
    def __init__(self, text: str = "", sort_value: Any = None):
        super().__init__(text)
        if sort_value is not None:
            try:
                self.setData(Qt.UserRole, sort_value)
            except Exception:
                pass

    def __lt__(self, other: "QTableWidgetItem") -> bool:
        try:
            a = self.data(Qt.UserRole)
            b = other.data(Qt.UserRole)
            if a is not None and b is not None:
                return a < b
        except Exception:
            pass
        return super().__lt__(other)


# -------------------- helpers --------------------
def _can(perm: str) -> bool:
    """UI nivo: fail-closed."""
    try:
        from core.session import can  # type: ignore
        return bool(can(perm))
    except Exception:
        return False


def _actor_name() -> str:
    try:
        from core.session import actor_name  # type: ignore
        return (actor_name() or "user").strip() or "user"
    except Exception:
        return "user"


def _actor_key() -> str:
    try:
        from core.session import actor_key  # type: ignore
        return (actor_key() or "").strip()
    except Exception:
        return ""


def _norm(s: Any) -> str:
    try:
        return str(s or "").strip()
    except Exception:
        return ""


def _cf(s: Any) -> str:
    return _norm(s).casefold()


def _status_key(raw: Any) -> str:
    """
    Normalizacija statusa u "ključ" (konzervativno + tolerantno).
    Cilj: stabilno bojenje redova i tab filteri, bez obzira na varijacije teksta u bazi.
    """
    s = _cf(raw)
    if not s:
        return "unknown"

    # "rashod/otpis" i slične varijante
    if (
        "rashod" in s
        or "otpis" in s
        or "otpisan" in s
        or s in ("scrapped", "retired", "disposed", "decommissioned", "inactive", "archived")
    ):
        return "scrapped"

    # standardna stanja iz UI dropdown-a
    if s in ("active", "in_use", "u_upotrebi", "upotrebi", "aktivno"):
        return "active"
    if s in ("on_loan", "loan", "assigned", "zaduzeno", "zaduženo", "zaduz", "duzi", "duži"):
        return "on_loan"
    if s in ("service", "repair", "servis", "u_servisu", "servisu", "kalibracija", "metrologija"):
        return "service"

    return s


def _safe_int(v: Any) -> Optional[int]:
    """
    Tolerantno izvlačenje broja iz bilo čega:
    - int -> int
    - float -> int
    - 'TOC 1234' -> 1234
    - None/čudan tip -> None
    """
    try:
        if v is None:
            return None
        if isinstance(v, bool):
            return None
        if isinstance(v, int):
            return v
        if isinstance(v, float):
            return int(v)

        s = str(v).strip()
        if not s:
            return None

        digits = "".join(ch for ch in s if ch.isdigit())
        if not digits:
            return None
        return int(digits)
    except Exception:
        return None


def _safe_dt_sort_value(v: Any) -> Optional[int]:
    """
    Sort ključ za datume:
    - datetime -> timestamp
    - ISO string -> timestamp
    """
    try:
        if v is None:
            return None

        try:
            import datetime as _dt
            if isinstance(v, _dt.datetime):
                return int(v.timestamp())
        except Exception:
            pass

        s = str(v or "").strip()
        if not s:
            return None

        try:
            from datetime import datetime
            s2 = s.replace("Z", "").replace("T", " ").strip()
            dt = datetime.fromisoformat(s2)
            return int(dt.timestamp())
        except Exception:
            return None
    except Exception:
        return None


def _row_as_dict(r: Any) -> Dict[str, Any]:
    """Servisi mogu vratiti dict ili sqlite3.Row; normalizuj u dict (fail-safe)."""
    if r is None:
        return {}
    if isinstance(r, dict):
        return r
    try:
        return dict(r)
    except Exception:
        return {}


def _get_nomenclature(r: Dict[str, Any]) -> str:
    """
    Nomenklaturni broj — tolerantno:
    - kanonsko u DB je 'nomenclature_number'
    - ali UI i dijalozi mogu vratiti razne alias-e
    """
    for k in (
        "nomenclature_number",
        "nomenclature_no",
        "nomenklaturni_broj",
        "nomenklatura_broj",
        "nom_broj",
        "nom_no",
        "nomen",
    ):
        try:
            v = str(r.get(k, "") or "").strip()
            if v:
                return v
        except Exception:
            continue
    return ""


def _is_unassigned(r: Dict[str, Any]) -> bool:
    # robustnije: neki servisi koriste assigned_to umesto current_holder
    return not _norm(r.get("current_holder", "") or r.get("assigned_to", ""))


def _is_scrapped(r: Dict[str, Any]) -> bool:
    # tolerantno na "rashod/otpis/retired" varijante
    return _status_key(r.get("status", "")) == "scrapped"


def _scope_candidates_lower() -> List[str]:
    """Kandidati identiteta za MY filter u UI (konzervativno): actor_key + actor_name."""
    cand: List[str] = []
    ak = _actor_key()
    if ak:
        cand.append(ak)
    an = _actor_name()
    if an:
        cand.append(an)

    out: List[str] = []
    seen = set()
    for c in cand:
        cc = str(c or "").strip().casefold()
        if cc and cc not in seen:
            seen.add(cc)
            out.append(cc)
    return out


def _is_my_asset_ui(r: Dict[str, Any]) -> bool:
    """UI filter za "Moja oprema" (samo kad user IMA assets.view pa bi servis vratio sve)."""
    holder = _norm(r.get("current_holder", "") or r.get("assigned_to", ""))
    if not holder:
        return False
    h = holder.casefold()
    return any(h == c for c in _scope_candidates_lower())


def _is_metro_asset_ui(r: Dict[str, Any]) -> bool:
    """UI filter za "Metrologija (scope)" (konzervativno)."""
    cat = _cf(r.get("category", ""))
    if "metrolog" in cat:
        return True
    for k in (
        "is_metrology", "is_metro", "metrology_flag", "metro_flag",
        "metrology_scope", "calibration_required", "needs_calibration",
    ):
        if k in r:
            try:
                if bool(r.get(k)):
                    return True
            except Exception:
                pass
    return False


def _try_create_assignment_after_create(asset_uid: str, to_holder: str, to_location: str = "", note: str = "") -> None:
    """Best-effort: kreiraj zaduženje (assign) nakon kreiranja sredstva."""
    holder = (to_holder or "").strip()
    if not asset_uid or not holder:
        return

    try:
        from services.assignments_service import create_assignment  # type: ignore
        create_assignment(
            actor=_actor_name(),
            asset_uid=asset_uid,
            action="assign",
            to_holder=holder,
            to_location=(to_location or "").strip(),
            note=(note or "").strip(),
            source="ui_new_asset_autozad",
        )
        return
    except Exception:
        pass

    try:
        from core.db import create_assignment_db  # type: ignore
        create_assignment_db(
            actor=_actor_name(),
            asset_uid=asset_uid,
            action="assign",
            to_holder=holder,
            to_location=(to_location or "").strip(),
            note=(note or "").strip(),
            source="ui_new_asset_autozad",
        )
    except Exception:
        return


# -------------------- Row tint delegate (kao Metrology Dashboard) --------------------
class _AssetsRowTintDelegate(QStyledItemDelegate):
    """
    Selection-aware row tint + left accent stripe (kao ui/metrology_dashboard_page.py),
    bez ručnog farbanja svake ćelije (brže + stabilnije).

    FIX (edge-case):
    - Accent traka sada ide uz *prvu vidljivu* kolonu (ako user sakrije kolonu #/UID),
      umesto da "nestane" kad je 0-ta kolona sakrivena.
    - Accent se crta POSLE standardnog paint-a, da ostane vidljiv i na selekciji.
    """
    def __init__(
        self,
        table: QTableWidget,
        status_col: int,
        palette: Dict[str, Tuple[QColor, QColor]],
        accent_px: int = 3,
    ):
        super().__init__(table)
        self._tbl = table
        self._status_col = int(status_col)
        self._accent_px = max(1, int(accent_px))
        self._palette = dict(palette or {})

    def _status_for_row(self, row: int) -> str:
        try:
            it = self._tbl.item(row, self._status_col)
            return _status_key(it.text() if it else "")
        except Exception:
            return "unknown"

    def _first_visible_logical_col(self) -> int:
        try:
            hdr = self._tbl.horizontalHeader()
            # idemo po visual index-u (redosled na ekranu), nađi prvi koji NIJE sakriven
            for vi in range(int(hdr.count())):
                li = int(hdr.logicalIndex(vi))
                if li >= 0 and (not hdr.isSectionHidden(li)):
                    return li
        except Exception:
            pass
        return 0

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index) -> None:
        try:
            row = int(index.row())
            logical_col = int(index.column())
        except Exception:
            super().paint(painter, option, index)
            return

        st = self._status_for_row(row)
        accent, tint = self._palette.get(
            st,
            self._palette.get("unknown", (QColor("#a0a6b6"), QColor(0, 0, 0, 0))),
        )

        is_selected = bool(option.state & QStyle.State_Selected)

        # 1) Row tint (samo kad NIJE selektovano)
        if not is_selected:
            painter.save()
            painter.fillRect(option.rect, tint)
            painter.restore()

        # 2) Default paint (selekcija + tekst + fokus)
        super().paint(painter, option, index)

        # 3) Accent stripe (uvek vidljiv, čak i na selekciji)
        try:
            if logical_col == self._first_visible_logical_col():
                painter.save()
                r = QRect(option.rect)
                stripe = QRect(r.left(), r.top(), self._accent_px, r.height())
                painter.fillRect(stripe, accent)
                painter.restore()
        except Exception:
            pass


# -------------------- Preview panel --------------------
class AssetPreviewPanel(QFrame):
    """Desni read-only panel za brz pregled selektovanog sredstva + collapse/expand."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.StyledPanel)
        self.setObjectName("assetPreviewPanel")

        self._collapsed = False
        self._expanded_min_w = 320
        self._collapsed_w = 64

        # Handler reference + wrapper slot reference (da disconnect radi 100% bez warning-a)
        self._open_handler: Optional[Callable[[], None]] = None
        self._open_slot: Optional[Callable[..., None]] = None

        self._toggle_handler: Optional[Callable[[], None]] = None
        self._toggle_slot: Optional[Callable[..., None]] = None

        self.title = QLabel("Pregled sredstva")
        try:
            self.title.setStyleSheet("font-weight: 700; font-size: 14px;")
        except Exception:
            pass

        self.btn_toggle_close = QToolButton(self)
        self.btn_toggle_close.setAutoRaise(False)
        self.btn_toggle_close.setCursor(QCursor(Qt.PointingHandCursor))
        self.btn_toggle_close.setIconSize(QSize(16, 16))
        self.btn_toggle_close.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self.btn_toggle_close.setText("Sakrij pregled")
        self.btn_toggle_close.setToolTip("Sakrij panel pregleda")

        self.btn_toggle_open = QToolButton(self)
        self.btn_toggle_open.setAutoRaise(False)
        self.btn_toggle_open.setCursor(QCursor(Qt.PointingHandCursor))
        self.btn_toggle_open.setIconSize(QSize(18, 18))
        self.btn_toggle_open.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        # IMPORTANT: \n ostaje u stringu (Qt multiline), ne menjati u triple-quote tekst
        self.btn_toggle_open.setText("P\nR\nE\nG\nL\nE\nD")
        self.btn_toggle_open.setToolTip("Prikaži pregled")
        self.btn_toggle_open.hide()

        try:
            base = (
                "QToolButton{"
                "  color: rgba(255,255,255,0.92);"
                "  border: 1px solid rgba(255,255,255,0.30);"
                "  background: qlineargradient(x1:0,y1:0,x2:0,y2:1,"
                "    stop:0 rgba(255,255,255,0.14),"
                "    stop:1 rgba(255,255,255,0.07)"
                "  );"
                "}"
                "QToolButton:hover{"
                "  border-color: rgba(255,255,255,0.55);"
                "  background: qlineargradient(x1:0,y1:0,x2:0,y2:1,"
                "    stop:0 rgba(255,255,255,0.20),"
                "    stop:1 rgba(255,255,255,0.10)"
                "  );"
                "}"
                "QToolButton:pressed{"
                "  background: rgba(255,255,255,0.22);"
                "}"
                "QToolButton:focus{"
                "  border-color: rgba(90,170,255,0.85);"
                "}"
            )
            self.btn_toggle_close.setStyleSheet(base + "QToolButton{ padding: 6px 10px; border-radius: 12px; }")
            self.btn_toggle_open.setStyleSheet(base + "QToolButton{ padding: 10px 8px; border-radius: 16px; }")
        except Exception:
            pass

        self._refresh_toggle_icons()

        self._header_expanded = QWidget(self)
        header_lay = QHBoxLayout(self._header_expanded)
        header_lay.setContentsMargins(0, 0, 0, 0)
        header_lay.setSpacing(8)
        header_lay.addWidget(self.title, 1)
        header_lay.addWidget(self.btn_toggle_close, 0, Qt.AlignRight)

        self._header_collapsed = QWidget(self)
        collapsed_lay = QVBoxLayout(self._header_collapsed)
        collapsed_lay.setContentsMargins(0, 0, 0, 0)
        collapsed_lay.setSpacing(0)
        collapsed_lay.addStretch(1)
        collapsed_lay.addWidget(self.btn_toggle_open, 0, Qt.AlignHCenter)
        collapsed_lay.addStretch(1)
        self._header_collapsed.hide()

        self._fields: Dict[str, QLabel] = {}
        self.form = QFormLayout()
        self.form.setLabelAlignment(Qt.AlignLeft)
        self.form.setFormAlignment(Qt.AlignTop)

        def _add(key: str, label: str) -> None:
            v = QLabel("—")
            v.setTextInteractionFlags(Qt.TextSelectableByMouse)
            v.setWordWrap(True)
            self._fields[key] = v
            self.form.addRow(QLabel(label), v)

        _add("asset_uid", "Asset UID:")
        _add("rb", "RB:")
        _add("toc_number", "TOC:")
        _add("nomenclature", "Nomenkl. broj:")
        _add("serial_number", "Serijski:")
        _add("name", "Naziv:")
        _add("category", "Kategorija:")
        _add("status", "Status:")
        _add("current_holder", "Zaduženo kod:")
        _add("location", "Lokacija:")
        _add("updated_at", "Ažurirano:")

        self.btn_open = QPushButton("Otvori detalje")
        self.btn_copy_uid = QPushButton("Kopiraj UID")

        self._current_uid = ""
        self.btn_copy_uid.clicked.connect(self._copy_uid)

        btns = QHBoxLayout()
        btns.addWidget(self.btn_open, 1)
        btns.addWidget(self.btn_copy_uid, 1)

        self._content = QWidget(self)
        content_lay = QVBoxLayout(self._content)
        content_lay.addLayout(self.form)
        content_lay.addStretch(1)
        content_lay.addLayout(btns)

        lay = QVBoxLayout(self)
        lay.setContentsMargins(8, 8, 8, 8)
        lay.setSpacing(8)
        lay.addWidget(self._header_expanded)
        lay.addWidget(self._header_collapsed, 1)
        lay.addWidget(self._content, 1)

        self.setMinimumWidth(self._expanded_min_w)

    def collapsed_width(self) -> int:
        return int(self._collapsed_w)

    def expanded_width_hint(self) -> int:
        return int(self._expanded_min_w)

    def set_toggle_enabled(self, enabled: bool) -> None:
        try:
            self.btn_toggle_close.setEnabled(enabled)
            self.btn_toggle_open.setEnabled(enabled)
        except Exception:
            pass

    def set_open_handler(self, fn: Callable[[], None]) -> None:
        """
        FIX: nema više disconnect(None) warning-a.
        Klik signali u Qt često imaju potpis clicked(bool) — wrapper prihvata *args.
        """
        if self._open_slot is not None:
            try:
                self.btn_open.clicked.disconnect(self._open_slot)
            except Exception:
                pass

        self._open_handler = fn

        def _slot(*_args: Any, **_kwargs: Any) -> None:
            try:
                if self._open_handler:
                    self._open_handler()
            except Exception:
                return

        self._open_slot = _slot
        try:
            self.btn_open.clicked.connect(self._open_slot)
        except Exception:
            pass

    def set_toggle_handler(self, fn: Callable[[], None]) -> None:
        """
        FIX: nema disconnect(None) warning-a + jedan wrapper za oba dugmeta.
        """
        if self._toggle_slot is not None:
            for btn in (self.btn_toggle_close, self.btn_toggle_open):
                try:
                    btn.clicked.disconnect(self._toggle_slot)
                except Exception:
                    pass

        self._toggle_handler = fn

        def _slot(*_args: Any, **_kwargs: Any) -> None:
            try:
                if self._toggle_handler:
                    self._toggle_handler()
            except Exception:
                return

        self._toggle_slot = _slot

        for btn in (self.btn_toggle_close, self.btn_toggle_open):
            try:
                btn.clicked.connect(self._toggle_slot)
            except Exception:
                pass

    def is_collapsed(self) -> bool:
        return bool(self._collapsed)

    def prepare_expand_animation(self) -> None:
        try:
            self._header_expanded.hide()
            self._content.hide()
            self.btn_toggle_open.show()
            self._header_collapsed.show()
            self.setMinimumWidth(self._collapsed_w)
            self.setMaximumWidth(16777215)
        except Exception:
            pass

    def finish_expand_animation(self) -> None:
        self.set_collapsed(False)

    def prepare_collapse_animation(self) -> None:
        try:
            self._header_collapsed.hide()
            self.btn_toggle_open.hide()
            self._header_expanded.show()
            self._content.hide()
            self.setMinimumWidth(0)
            self.setMaximumWidth(16777215)
        except Exception:
            pass

    def finish_collapse_animation(self) -> None:
        self.set_collapsed(True)

    def set_collapsed(self, collapsed: bool) -> None:
        self._collapsed = bool(collapsed)
        self._refresh_toggle_icons()

        if self._collapsed:
            self._content.hide()
            self._header_expanded.hide()
            self.btn_toggle_open.show()
            self._header_collapsed.show()
            self.setMinimumWidth(self._collapsed_w)
            self.setMaximumWidth(self._collapsed_w)
        else:
            self._header_collapsed.hide()
            self.btn_toggle_open.hide()
            self._header_expanded.show()
            self._content.show()
            self.setMinimumWidth(self._expanded_min_w)
            self.setMaximumWidth(16777215)

    def _refresh_toggle_icons(self) -> None:
        try:
            style = self.style()
            self.btn_toggle_close.setIcon(style.standardIcon(QStyle.SP_ArrowRight))
            self.btn_toggle_open.setIcon(style.standardIcon(QStyle.SP_ArrowLeft))
        except Exception:
            pass

    def clear(self) -> None:
        self._current_uid = ""
        for v in self._fields.values():
            v.setText("—")
            try:
                v.setStyleSheet("")
            except Exception:
                pass

    def set_asset(self, r: Dict[str, Any]) -> None:
        if not isinstance(r, dict) or not r:
            self.clear()
            return

        uid = _norm(r.get("asset_uid", ""))
        self._current_uid = uid

        def _set(key: str, text: str) -> None:
            lb = self._fields.get(key)
            if lb:
                lb.setText(text if text else "—")

        _set("asset_uid", uid)
        _set("rb", _norm(r.get("rb", "")))
        _set("toc_number", _norm(r.get("toc_number", "")))

        nom = _get_nomenclature(r)
        _set("nomenclature", nom)

        _set("serial_number", _norm(r.get("serial_number", "")))
        _set("name", _norm(r.get("name", "")))
        _set("category", _norm(r.get("category", "")))
        _set("status", _norm(r.get("status", "")))
        _set("current_holder", _norm(r.get("current_holder", "")))
        _set("location", _norm(r.get("location", "")))

        raw_upd = r.get("updated_at", "") or ""
        try:
            disp = fmt_dt_sr(raw_upd)
        except Exception:
            disp = _norm(raw_upd)
        _set("updated_at", disp)

        try:
            lb_nom = self._fields.get("nomenclature")
            if lb_nom:
                lb_nom.setStyleSheet("" if nom else "color: #ff8a80; font-weight: 600;")
                lb_nom.setToolTip("" if nom else "Nomenklaturni broj nije unet.")
        except Exception:
            pass

    def _copy_uid(self) -> None:
        uid = (self._current_uid or "").strip()
        if not uid:
            return
        try:
            QApplication.clipboard().setText(uid)
        except Exception:
            pass

# (FILENAME: ui/assets_page.py - END)  [PART 1/3]

# FILENAME: ui/assets_page.py
# (FILENAME: ui/assets_page.py - START)  [PART 2/3]

class AssetsPage(QWidget):
    COLS = [
        "#",
        "Asset UID", "TOC", "Nomenkl. broj", "Serijski",
        "Naziv", "Kategorija", "Status",
        "Zaduženo kod", "Lokacija", "Ažurirano"
    ]

    COL_IDX_ROWNUM = 0
    COL_IDX_UID = 1
    COL_IDX_TOC = 2
    COL_IDX_NOM = 3
    COL_IDX_SN = 4
    COL_IDX_NAME = 5
    COL_IDX_CAT = 6
    COL_IDX_STATUS = 7
    COL_IDX_HOLDER = 8
    COL_IDX_LOC = 9
    COL_IDX_UPD = 10

    TAB_ACTIVE = "Aktivna"
    TAB_UNASSIGNED = "Bez zaduženja"
    TAB_SCRAPPED = "Rashodovana"
    TAB_ALL = "Sva"

    SCOPE_ALL = "Sva sredstva"
    SCOPE_MY = "Moja oprema"
    SCOPE_METRO = "Metrologija (scope)"

    def __init__(self, logger: logging.Logger, parent=None):
        super().__init__(parent)
        self.setObjectName("AssetsPage")

        self.logger = logger or logging.getLogger(__name__)

        self._has_any_view = False
        self._has_full_view = False
        self._has_my_view = False
        self._has_metro_view = False

        self._preview_collapsed = False
        self._preview_last_w: Optional[int] = None
        self._preview_anim: Optional[QVariantAnimation] = None
        self._preview_animating: bool = False

        self._anim_last_right: Optional[int] = None
        self._anim_saved_stretch_last: Optional[bool] = None
        self._anim_saved_vp_mode: Optional[QAbstractItemView.ViewportUpdateMode] = None

        self._loading: bool = False
        self._hidden_cache: List[bool] = []

        self._sort_col: int = -1
        self._sort_order: Qt.SortOrder = Qt.AscendingOrder

        # status palette (row tint + accent + status text)
        self._row_paint_palette: Dict[str, Tuple[QColor, QColor]] = {}
        self._status_text_color: Dict[str, QColor] = {}
        self._init_status_palette()

        # Debounce reload (sprečava spam DB poziva)
        self._reload_timer = QTimer(self)
        self._reload_timer.setSingleShot(True)
        self._reload_timer.setInterval(180)
        self._reload_timer.timeout.connect(self._on_reload_timeout)

        # Kolone: key-evi ostaju kompatibilni sa starim podešavanjima
        self._col_specs = [
            ColSpec(key="rownum", label="#", default_visible=True, default_width=60),
            ColSpec(key="asset_uid", label="Asset UID", default_visible=True, default_width=160),
            ColSpec(key="toc_number", label="TOC", default_visible=True, default_width=120),
            ColSpec(key="nomenclature_no", label="Nomenkl. broj", default_visible=True, default_width=150),
            ColSpec(key="serial_number", label="Serijski", default_visible=True, default_width=140),
            ColSpec(key="name", label="Naziv", default_visible=True, default_width=260),
            ColSpec(key="category", label="Kategorija", default_visible=True, default_width=140),
            ColSpec(key="status", label="Status", default_visible=True, default_width=120),
            ColSpec(key="current_holder", label="Zaduženo kod", default_visible=True, default_width=160),
            ColSpec(key="location", label="Lokacija", default_visible=True, default_width=160),
            ColSpec(key="updated_at", label="Ažurirano", default_visible=True, default_width=150),
        ]

        # --- Tabs ---
        self.tabs = QTabWidget()
        self.tabs.addTab(QWidget(), self.TAB_ACTIVE)
        self.tabs.addTab(QWidget(), self.TAB_UNASSIGNED)
        self.tabs.addTab(QWidget(), self.TAB_SCRAPPED)
        self.tabs.addTab(QWidget(), self.TAB_ALL)

        # --- Filters ---
        self.cb_scope = QComboBox()
        self.cb_scope.setToolTip("Opseg prikaza (RBAC + scope)")

        self.ed_search = QLineEdit()
        self.ed_search.setPlaceholderText(
            "DB pretraga: RB / UID / TOC / nomenkl. broj / serijski / naziv / lokacija / zaduženo kod"
        )
        self.ed_search.setClearButtonEnabled(True)

        self.cb_category = QComboBox()
        self.cb_category.addItems(["SVE", "IT", "Metrologija", "OS", "SI", "Zalihe", "Ostalo"])

        self.cb_status = QComboBox()
        self.cb_status.addItems(["SVE", "active", "on_loan", "service", "scrapped"])

        # --- Buttons ---
        self.btn_search = QPushButton("Pretraži")
        self.btn_search.setToolTip("Primeni DB pretragu (isto kao Enter u polju)")

        self.btn_refresh = QPushButton("Osveži")
        self.btn_refresh.setToolTip("Osveži listu (debounce)")

        self.btn_columns = QPushButton("Kolone")
        self.btn_columns.setToolTip("Podešavanje vidljivosti i širine kolona")

        self.btn_detail = QPushButton("Detalji")
        self.btn_detail.setEnabled(False)
        self.btn_detail.setToolTip("Otvori detalje selektovanog sredstva (dupli klik radi isto)")

        self.btn_new = QPushButton("Novo")
        self.btn_new.setToolTip("Kreiraj novo sredstvo")

        # --- RBAC banner ---
        self.lb_rbac = QLabel("")
        self.lb_rbac.setWordWrap(True)
        self.lb_rbac.hide()

        top = QHBoxLayout()
        top.addWidget(QLabel("Opseg:"))
        top.addWidget(self.cb_scope, 1)
        top.addWidget(self.ed_search, 3)
        top.addWidget(self.btn_search)
        top.addWidget(QLabel("Kategorija:"))
        top.addWidget(self.cb_category, 1)
        top.addWidget(QLabel("Status:"))
        top.addWidget(self.cb_status, 1)
        top.addWidget(self.btn_refresh)
        top.addWidget(self.btn_columns)
        top.addWidget(self.btn_detail)
        top.addWidget(self.btn_new)

        # --- Table ---
        self.table = QTableWidget(0, len(self.COLS))
        self.table.setObjectName("assetsTable")  # za QSS target
        self.table.setHorizontalHeaderLabels(self.COLS)

        # UX: zadržavamo SelectItems jer copy helper radi najfleksibilnije nad selekcijom ćelija
        self.table.setSelectionBehavior(QAbstractItemView.SelectItems)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setAlternatingRowColors(True)

        # ✅ Excel-like numeracija sa leve strane (row header)
        vh = self.table.verticalHeader()
        vh.setVisible(True)
        try:
            vh.setDefaultAlignment(Qt.AlignRight | Qt.AlignVCenter)
        except Exception:
            pass
        try:
            vh.setSectionResizeMode(QHeaderView.Fixed)
        except Exception:
            pass
        try:
            vh.setDefaultSectionSize(30)
        except Exception:
            pass
        try:
            vh.setFixedWidth(48)
        except Exception:
            pass

        # ✅ Jače/granularnije linije (više kao metrology dashboard)
        try:
            self.table.setShowGrid(True)
            self.table.setGridStyle(Qt.SolidLine)
        except Exception:
            pass

        try:
            self.table.setUniformRowHeights(True)  # type: ignore[attr-defined]
        except Exception:
            pass

        try:
            self.table.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
            self.table.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
        except Exception:
            pass

        hdr = self.table.horizontalHeader()
        hdr.setStretchLastSection(True)
        hdr.setSectionsClickable(True)
        hdr.setSectionsMovable(True)
        hdr.setDefaultAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        try:
            hdr.setSectionResizeMode(QHeaderView.Interactive)
            hdr.setFixedHeight(36)
        except Exception:
            pass

        # sort
        self.table.setSortingEnabled(True)

        # copy helper (fail-safe)
        try:
            if wire_table_selection_plus_copy is not None:
                wire_table_selection_plus_copy(self.table)
        except Exception:
            pass

        # ✅ Row tint delegate (kao metrology dashboard)
        self._row_tint_delegate = _AssetsRowTintDelegate(
            self.table,
            status_col=self.COL_IDX_STATUS,
            palette=self._row_paint_palette,
            accent_px=3,
        )
        self.table.setItemDelegate(self._row_tint_delegate)

        # ✅ QSS za granice ćelija + header separatore (neutralna siva da radi i na dark/light)
        try:
            self.table.setStyleSheet(
                "QTableWidget#assetsTable {"
                "  gridline-color: rgba(140,140,140,0.45);"
                "}"
                "QTableWidget#assetsTable::item {"
                "  border-right: 1px solid rgba(140,140,140,0.22);"
                "  border-bottom: 1px solid rgba(140,140,140,0.28);"
                "  padding: 4px 6px;"
                "}"
                "QTableWidget#assetsTable QHeaderView::section {"
                "  border-right: 1px solid rgba(140,140,140,0.32);"
                "  border-bottom: 1px solid rgba(140,140,140,0.42);"
                "  padding: 6px 8px;"
                "}"
                "QTableWidget#assetsTable QHeaderView::section:vertical {"
                "  padding: 0px 6px;"
                "}"
            )
        except Exception:
            pass

        # --- Quick tools (instant filter + sort toggle) ---
        if TableToolsBar is not None and TableToolsConfig is not None:
            self.quick_tools = TableToolsBar(
                self.table,
                TableToolsConfig(
                    placeholder="Brzi filter (instant): npr. fluke 1234 nom-55 pera",
                    show_sort_toggle=True,
                    default_sort_enabled=True,
                    filter_columns=[
                        self.COL_IDX_UID,
                        self.COL_IDX_TOC,
                        self.COL_IDX_NOM,
                        self.COL_IDX_SN,
                        self.COL_IDX_NAME,
                        self.COL_IDX_CAT,
                        self.COL_IDX_STATUS,
                        self.COL_IDX_HOLDER,
                        self.COL_IDX_LOC,
                    ],
                ),
                parent=self,
            )
        else:
            self.quick_tools = QLabel("")  # fail-safe placeholder
            self.quick_tools.setVisible(False)

        # --- Preview panel ---
        self.preview = AssetPreviewPanel(self)
        self.preview.set_open_handler(self.open_selected_detail)
        self.preview.set_toggle_handler(self._toggle_preview)

        # --- Splitter ---
        self.splitter = QSplitter(Qt.Horizontal)
        self.splitter.addWidget(self.table)
        self.splitter.addWidget(self.preview)
        self.splitter.setStretchFactor(0, 4)
        self.splitter.setStretchFactor(1, 1)

        lay = QVBoxLayout(self)
        lay.addWidget(self.tabs)
        lay.addLayout(top)
        lay.addWidget(self.quick_tools)
        lay.addWidget(self.lb_rbac)
        lay.addWidget(self.splitter, 1)

        # --- Signals ---
        self.btn_refresh.clicked.connect(self.request_reload)
        self.btn_search.clicked.connect(self.request_reload)
        self.btn_new.clicked.connect(self.new_asset)
        self.btn_detail.clicked.connect(self.open_selected_detail)

        self.tabs.currentChanged.connect(lambda _i: self.request_reload())
        self.cb_scope.currentIndexChanged.connect(lambda _i: self.request_reload())

        # Debounce već štiti DB od “spam-a”
        self.ed_search.textChanged.connect(lambda _t: self.request_reload())
        self.ed_search.returnPressed.connect(self.request_reload)

        self.cb_category.currentIndexChanged.connect(lambda _i: self.request_reload())
        self.cb_status.currentIndexChanged.connect(lambda _i: self.request_reload())

        self.table.cellDoubleClicked.connect(self.open_detail)
        self.table.itemSelectionChanged.connect(self._on_selection_changed)

        try:
            self.table.horizontalHeader().sortIndicatorChanged.connect(self._on_sort_changed)
        except Exception:
            pass

        # Kolone: persist key
        if wire_columns is not None:
            self._apply_cols_assets = wire_columns(
                self, self.table, self.btn_columns, "assets_table_v9", self._col_specs
            )
        else:
            self._apply_cols_assets = lambda: None

        # Renumber sync (za instant filter hideRow)
        self._sync_timer = QTimer(self)
        self._sync_timer.setInterval(250)
        self._sync_timer.timeout.connect(self._poll_hidden_for_renumber)
        self._sync_timer.start()

        self._apply_rbac()
        if self._has_any_view:
            self.request_reload()

    def _init_status_palette(self) -> None:
        """
        Jedno mesto istine za boje:
        - row tint (suptilan)
        - accent stripe (jače)
        - status text (čitljivo na light/dark)
        """
        self._row_paint_palette = {
            "active":   (QColor("#22c55e"), QColor(34, 197, 94, 28)),
            "on_loan":  (QColor("#3b82f6"), QColor(59, 130, 246, 26)),
            "service":  (QColor("#ffcc00"), QColor(255, 204, 0, 24)),
            "scrapped": (QColor("#a0a6b6"), QColor(160, 166, 182, 22)),
            "unknown":  (QColor("#a0a6b6"), QColor(0, 0, 0, 0)),
        }
        self._status_text_color = {
            "active": QColor("#22c55e"),
            "on_loan": QColor("#3b82f6"),
            "service": QColor("#ffcc00"),
            "scrapped": QColor("#a0a6b6"),
            "unknown": QColor("#b9beca"),
        }

    def _on_reload_timeout(self) -> None:
        """Timer callback: poziva load_assets ako postoji (fail-safe)."""
        try:
            fn = getattr(self, "load_assets", None)
            if callable(fn):
                fn()
        except Exception:
            try:
                self.logger.exception("AssetsPage: reload timeout failed")
            except Exception:
                pass

    def request_reload(self) -> None:
        """Debounce reload."""
        if not self._has_any_view:
            return
        try:
            self._reload_timer.start()
        except Exception:
            try:
                self.load_assets()
            except Exception:
                pass

    # -------------------- RBAC --------------------
    def _apply_rbac(self) -> None:
        self._has_full_view = _can(PERM_ASSETS_VIEW)
        self._has_my_view = _can(PERM_ASSETS_MY_VIEW)
        self._has_metro_view = _can(PERM_ASSETS_METRO_VIEW)
        self._has_any_view = self._has_full_view or self._has_my_view or self._has_metro_view

        self.cb_scope.blockSignals(True)
        try:
            self.cb_scope.clear()
            if self._has_full_view:
                self.cb_scope.addItem(self.SCOPE_ALL)
            if self._has_my_view:
                self.cb_scope.addItem(self.SCOPE_MY)
            if self._has_metro_view:
                self.cb_scope.addItem(self.SCOPE_METRO)
            # fail-safe: ne ostavljamo prazan combo ni u edge-case konfiguraciji
            if self.cb_scope.count() == 0:
                self.cb_scope.addItem(self.SCOPE_MY)
        finally:
            self.cb_scope.blockSignals(False)

        if not self._has_any_view:
            self.lb_rbac.setText(
                "Nemaš pravo da vidiš stranu 'Sredstva' "
                "(potrebno je assets.view ili assets.my.view ili assets.metrology.view)."
            )
            self.lb_rbac.show()

            for w in [
                self.tabs, self.cb_scope,
                self.ed_search, self.cb_category, self.cb_status,
                self.btn_search, self.btn_refresh, self.btn_columns,
                self.btn_detail, self.btn_new, self.table,
                self.quick_tools, self.preview, self.splitter,
            ]:
                try:
                    w.setEnabled(False)
                except Exception:
                    pass
            return

        ok_create = _can(PERM_ASSETS_CREATE) and self._has_any_view
        self.btn_new.setEnabled(ok_create)
        self.btn_new.setToolTip(
            "" if ok_create else "Novo sredstvo traži: assets.create + (assets.view ili assets.my.view ili assets.metrology.view)."
        )
        self.lb_rbac.hide()

    # -------------------- selection / preview --------------------
    def _current_row_any(self) -> int:
        r = self.table.currentRow()
        if r >= 0:
            return r
        try:
            sm = self.table.selectionModel()
            if sm:
                idx = sm.selectedIndexes()
                if idx:
                    return idx[0].row()
        except Exception:
            pass
        return -1

    def _sync_buttons(self) -> None:
        self.btn_detail.setEnabled(self._current_row_any() >= 0 and self._has_any_view)

    def _selected_uid(self) -> str:
        row = self._current_row_any()
        if row < 0:
            return ""
        it = self.table.item(row, self.COL_IDX_UID)
        return it.text().strip() if it else ""

    def _rowdata_from_row(self, row: int) -> Dict[str, Any]:
        # pokušaj: izvući originalni dict iz UID item UserRole
        it_uid = self.table.item(row, self.COL_IDX_UID)
        if it_uid:
            try:
                d = it_uid.data(Qt.UserRole)
                if isinstance(d, dict):
                    return d
            except Exception:
                pass

        def _txt(c: int) -> str:
            it = self.table.item(row, c)
            return it.text().strip() if it else ""

        # FIX: RB nije isto što i broj reda (#). Ako nemamo originalni dict iz servisa, RB ostaje prazno.
        return {
            "asset_uid": _txt(self.COL_IDX_UID),
            "rb": "",
            "toc_number": _txt(self.COL_IDX_TOC),
            "nomenclature_number": _txt(self.COL_IDX_NOM),
            "serial_number": _txt(self.COL_IDX_SN),
            "name": _txt(self.COL_IDX_NAME),
            "category": _txt(self.COL_IDX_CAT),
            "status": _txt(self.COL_IDX_STATUS),
            "current_holder": _txt(self.COL_IDX_HOLDER),
            "location": _txt(self.COL_IDX_LOC),
            "updated_at": _txt(self.COL_IDX_UPD),
        }

    def _on_selection_changed(self) -> None:
        row = self._current_row_any()
        if row >= 0:
            self.preview.set_asset(self._rowdata_from_row(row))
        else:
            self.preview.clear()
        self._sync_buttons()

# (FILENAME: ui/assets_page.py - END)  [PART 2/3]

# FILENAME: ui/assets_page.py
# (FILENAME: ui/assets_page.py - START)  [PART 3/3]

    # -------------------- tab/scope/filter --------------------
    def _active_tab_name(self) -> str:
        try:
            return self.tabs.tabText(self.tabs.currentIndex())
        except Exception:
            return self.TAB_ACTIVE

    def _apply_tab_filter(self, rows: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        tab = self._active_tab_name()
        if tab == self.TAB_ACTIVE:
            return [r for r in rows if not _is_scrapped(r)]
        if tab == self.TAB_UNASSIGNED:
            return [r for r in rows if (not _is_scrapped(r)) and _is_unassigned(r)]
        if tab == self.TAB_SCRAPPED:
            return [r for r in rows if _is_scrapped(r)]
        return rows

    def _scope_name(self) -> str:
        try:
            return self.cb_scope.currentText().strip()
        except Exception:
            return self.SCOPE_ALL

    def _cat_match(self, selected_cat: str, value_cat: Any) -> bool:
        """
        Tolerantno mapiranje kategorija iz combobox-a na realne stringove u DB.
        FIX: "Ostalo" više ne vraća sve, nego samo ono što ne spada u prepoznate grupe.
        """
        sc = (selected_cat or "").strip().casefold()
        vc = _cf(value_cat)

        if sc in ("", "sve"):
            return True

        is_it = ("it" in vc) or (vc == "it")
        is_metro = ("metrolog" in vc)
        is_os = (vc == "os") or ("osnov" in vc)
        is_si = (vc == "si") or ("sitan" in vc)
        is_zalihe = ("zaliha" in vc)

        if sc == "it":
            return is_it
        if sc == "metrologija":
            return is_metro
        if sc == "os":
            return is_os
        if sc == "si":
            return is_si
        if sc == "zalihe":
            return is_zalihe
        if sc == "ostalo":
            # samo ono što NIJE prepoznato kao gore
            if not vc:
                return True
            return not (is_it or is_metro or is_os or is_si or is_zalihe)

        return vc == sc

    def _apply_local_filters(self, rows: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Lokalni filter (fail-safe):
        - radi i kad servis vrati “brief” listu bez DB filtera
        - tolerantno poređenje category/status da ne puca na varijacije
        """
        q = _cf(self.ed_search.text())
        cat = _norm(self.cb_category.currentText() or "SVE")
        st = _norm(self.cb_status.currentText() or "SVE")

        if cat and cat.upper() != "SVE":
            rows = [r for r in rows if self._cat_match(cat, (r or {}).get("category", ""))]

        if st and st.upper() != "SVE":
            ss = st.casefold()
            if ss == "scrapped":
                rows = [r for r in rows if _is_scrapped(r)]
            else:
                rows = [r for r in rows if _cf((r or {}).get("status", "")) == ss]

        if q:
            def _row_text(rr: Dict[str, Any]) -> str:
                parts = [
                    rr.get("rb", ""),
                    rr.get("asset_uid", ""),
                    rr.get("toc_number", ""),
                    _get_nomenclature(rr),
                    rr.get("serial_number", ""),
                    rr.get("name", ""),
                    rr.get("location", ""),
                    rr.get("current_holder", ""),
                ]
                return " ".join(str(x or "") for x in parts).casefold()

            rows = [r for r in rows if q in _row_text(r)]

        return rows

    # -------------------- styling helpers --------------------
    def _apply_status_cell_style(self, item: QTableWidgetItem, status_raw: Any) -> None:
        """
        Status ćelija: samo “badge-like” tekst (bold + boja),
        bez background-a — background radi delegate (kao metrology dashboard).
        """
        try:
            key = _status_key(status_raw)
            col = self._status_text_color.get(key, self._status_text_color.get("unknown", QColor("#b9beca")))

            item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            item.setForeground(QBrush(col))

            f = item.font()
            f.setBold(True)
            item.setFont(f)
        except Exception:
            pass

    def _apply_nomenclature_cell_style(self, item: QTableWidgetItem, nom: str) -> None:
        try:
            if nom:
                item.setToolTip("")
                return
            item.setToolTip("Nomenklaturni broj nije unet.")
            f = item.font()
            f.setBold(True)
            item.setFont(f)
            item.setForeground(QBrush(QColor("#ff8a80")))
            item.setText("—")
            item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        except Exception:
            pass

    # -------------------- excel-like row header numbering --------------------
    def _set_vheader_text(self, row: int, text: str) -> None:
        """Excel-like numeracija u vertical header-u, sa desnim poravnanjem."""
        try:
            vh = self.table.verticalHeader()
            it = self.table.verticalHeaderItem(row)
            if it is None:
                it = QTableWidgetItem("")
                self.table.setVerticalHeaderItem(row, it)
            it.setText(text)
            try:
                it.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
            except Exception:
                pass
            try:
                # minimalno, da izgleda “čisto”
                it.setFlags(Qt.ItemIsEnabled)
            except Exception:
                pass
            try:
                vh.setDefaultAlignment(Qt.AlignRight | Qt.AlignVCenter)
            except Exception:
                pass
        except Exception:
            pass

    # -------------------- renumber --------------------
    def _renumber_view_rows(self) -> None:
        """
        Renumber samo VIDLJIVE redove:
        - popunjava "#" kolonu (za copy/sort/use-case)
        - popunjava i left Excel-like row header numeraciju
        """
        try:
            if self._sort_col == self.COL_IDX_ROWNUM:
                # ako user sortira po "#", ne “krademo” mu redosled
                return

            visible = 0
            rc = self.table.rowCount()
            for r in range(rc):
                hidden = self.table.isRowHidden(r)
                if hidden:
                    txt = ""
                    sort_v = 0
                    self._set_vheader_text(r, "")
                else:
                    visible += 1
                    txt = str(visible)
                    sort_v = visible
                    self._set_vheader_text(r, txt)

                it = self.table.item(r, self.COL_IDX_ROWNUM)
                if it is None or not isinstance(it, SortableItem):
                    it = SortableItem("", sort_v)
                    it.setFlags(it.flags() & ~Qt.ItemIsEditable)
                    self.table.setItem(r, self.COL_IDX_ROWNUM, it)

                it.setText(txt)
                try:
                    it.setData(Qt.UserRole, sort_v)
                except Exception:
                    pass
                it.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)

        except Exception:
            pass

    def _on_sort_changed(self, col: int, order: Qt.SortOrder) -> None:
        self._sort_col = int(col)
        self._sort_order = order
        if self._sort_col != self.COL_IDX_ROWNUM:
            QTimer.singleShot(0, self._renumber_view_rows)

    def _poll_hidden_for_renumber(self) -> None:
        """Detektuje promenu hide/show (quick filter) i renumberuje vidljive redove."""
        try:
            if self._sort_col == self.COL_IDX_ROWNUM:
                return
            rc = self.table.rowCount()
            if rc <= 0:
                return
            if len(self._hidden_cache) != rc:
                self._hidden_cache = [False] * rc

            changed = False
            for r in range(rc):
                h = self.table.isRowHidden(r)
                if self._hidden_cache[r] != h:
                    self._hidden_cache[r] = h
                    changed = True

            if changed:
                self._renumber_view_rows()
        except Exception:
            return

    # -------------------- preview anim --------------------
    def _anim_optimize_begin(self) -> None:
        try:
            hdr = self.table.horizontalHeader()
            self._anim_saved_stretch_last = bool(hdr.stretchLastSection())
            hdr.setStretchLastSection(False)
        except Exception:
            self._anim_saved_stretch_last = None

        try:
            self._anim_saved_vp_mode = self.table.viewportUpdateMode()
            self.table.setViewportUpdateMode(QAbstractItemView.MinimalViewportUpdate)
        except Exception:
            self._anim_saved_vp_mode = None

    def _anim_optimize_end(self) -> None:
        try:
            hdr = self.table.horizontalHeader()
            if self._anim_saved_stretch_last is not None:
                hdr.setStretchLastSection(bool(self._anim_saved_stretch_last))
        except Exception:
            pass

        try:
            if self._anim_saved_vp_mode is not None:
                self.table.setViewportUpdateMode(self._anim_saved_vp_mode)
        except Exception:
            pass

        self._anim_saved_stretch_last = None
        self._anim_saved_vp_mode = None
        self._anim_last_right = None

    def _animate_splitter_right(
        self,
        start_right: int,
        end_right: int,
        duration_ms: int,
        on_finished: Optional[Callable[[], None]] = None,
    ) -> None:
        try:
            if self._preview_anim is not None:
                try:
                    self._preview_anim.stop()
                except Exception:
                    pass
                self._preview_anim = None

            self._anim_last_right = None
            self._anim_optimize_begin()

            anim = QVariantAnimation(self)
            anim.setStartValue(int(start_right))
            anim.setEndValue(int(end_right))
            anim.setDuration(int(duration_ms))
            anim.setEasingCurve(QEasingCurve.InOutSine)

            def _tick(val) -> None:
                try:
                    right = int(val)
                    if self._anim_last_right is not None and abs(right - self._anim_last_right) < 3:
                        return
                    self._anim_last_right = right
                    total = max(1, int(self.splitter.width()))
                    left = max(1, total - right)
                    self.splitter.setSizes([left, right])
                except Exception:
                    pass

            def _done() -> None:
                try:
                    self._preview_animating = False
                    self.preview.set_toggle_enabled(True)
                except Exception:
                    pass
                self._anim_optimize_end()
                if on_finished:
                    try:
                        on_finished()
                    except Exception:
                        pass

            anim.valueChanged.connect(_tick)
            anim.finished.connect(_done)
            self._preview_anim = anim

            self._preview_animating = True
            self.preview.set_toggle_enabled(False)
            anim.start()
        except Exception:
            try:
                self._preview_animating = False
                self.preview.set_toggle_enabled(True)
            except Exception:
                pass
            self._anim_optimize_end()
            if on_finished:
                try:
                    on_finished()
                except Exception:
                    pass

    def _toggle_preview(self) -> None:
        if self._preview_animating:
            return

        sizes = self.splitter.sizes()
        current_right = int(sizes[1] if sizes and len(sizes) >= 2 else self.preview.width())

        if not self._preview_collapsed:
            self._preview_last_w = max(current_right, self.preview.expanded_width_hint())
            self._preview_collapsed = True

            self.preview.prepare_collapse_animation()
            target = self.preview.collapsed_width()

            self._animate_splitter_right(
                start_right=current_right,
                end_right=target,
                duration_ms=260,
                on_finished=self.preview.finish_collapse_animation,
            )
        else:
            self._preview_collapsed = False
            target = int(self._preview_last_w or 360)
            target = max(target, self.preview.expanded_width_hint())

            self.preview.prepare_expand_animation()
            self._animate_splitter_right(
                start_right=current_right,
                end_right=target,
                duration_ms=290,
                on_finished=self.preview.finish_expand_animation,
            )

    # -------------------- data --------------------
    def load_assets(self) -> None:
        if not self._has_any_view:
            return
        if self._loading:
            return

        self._loading = True
        selected_uid_before = self._selected_uid()

        # čuvamo sort indikator (da user ne “izgubi” svoj sort posle refresh-a)
        prev_sort_col = -1
        prev_sort_order = Qt.AscendingOrder
        try:
            hdr = self.table.horizontalHeader()
            prev_sort_col = int(hdr.sortIndicatorSection())
            prev_sort_order = hdr.sortIndicatorOrder()
        except Exception:
            pass

        was_sorting = False
        try:
            QApplication.setOverrideCursor(Qt.WaitCursor)

            try:
                was_sorting = self.table.isSortingEnabled()
                self.table.setSortingEnabled(False)
            except Exception:
                pass

            scope = self._scope_name()

            # 1) servisni fetch (RBAC u servisu)
            try:
                if scope == self.SCOPE_ALL:
                    rows_any = list_assets(
                        search=self.ed_search.text(),
                        category=self.cb_category.currentText(),
                        status=self.cb_status.currentText(),
                        limit=5000,
                    )
                else:
                    # brief (servis tipično već vraća MY/METRO scope)
                    try:
                        rows_any = list_assets_brief(limit=5000, metrology_only=(scope == self.SCOPE_METRO))
                    except TypeError:
                        rows_any = list_assets_brief(limit=5000)
            except Exception as e_fetch:
                try:
                    self.logger.exception("AssetsPage.load_assets fetch failed: %s", e_fetch)
                except Exception:
                    pass
                QMessageBox.critical(self, "Greška", f"Ne mogu da učitam sredstva (servis).\n\n{e_fetch}")
                return

            rows = [_row_as_dict(r) for r in (rows_any or [])]
            rows = [r for r in rows if isinstance(r, dict) and r]

            # 2) tab filter
            rows = self._apply_tab_filter(rows)

            # 3) UI scope filter samo ako user ima full_view
            if self._has_full_view:
                if scope == self.SCOPE_MY:
                    rows = [r for r in rows if _is_my_asset_ui(r)]
                elif scope == self.SCOPE_METRO:
                    rows = [r for r in rows if _is_metro_asset_ui(r)]

            # 4) lokalni filter
            rows = self._apply_local_filters(rows)

            # 5) render
            self.table.setUpdatesEnabled(False)
            self.table.blockSignals(True)
            try:
                self.table.clearContents()
                self.table.setRowCount(len(rows))
                self._hidden_cache = [False] * len(rows)

                # reset renumber tracking
                self._sort_col = -1
                self._sort_order = Qt.AscendingOrder

                for i, r in enumerate(rows):
                    # excel-like row header numeracija (levo)
                    self._set_vheader_text(i, str(i + 1))

                    # #
                    it0 = SortableItem(str(i + 1), i + 1)
                    it0.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                    self.table.setItem(i, self.COL_IDX_ROWNUM, it0)

                    # UID (+ stash row dict)
                    uid = _norm(r.get("asset_uid", ""))
                    it_uid = QTableWidgetItem(uid)
                    try:
                        it_uid.setData(Qt.UserRole, r)
                    except Exception:
                        pass
                    self.table.setItem(i, self.COL_IDX_UID, it_uid)

                    # TOC (numeric sort)
                    toc = _norm(r.get("toc_number", ""))
                    toc_num = _safe_int(toc)
                    it_toc = SortableItem(toc, toc_num)
                    it_toc.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                    self.table.setItem(i, self.COL_IDX_TOC, it_toc)

                    # Nomenkl. broj (numeric sort) + missing style
                    nom = _get_nomenclature(r)
                    nom_num = _safe_int(nom)
                    it_nom = SortableItem(nom, nom_num)
                    self._apply_nomenclature_cell_style(it_nom, nom)
                    self.table.setItem(i, self.COL_IDX_NOM, it_nom)

                    # ostalo
                    it_sn = QTableWidgetItem(_norm(r.get("serial_number", "")))
                    self.table.setItem(i, self.COL_IDX_SN, it_sn)

                    it_name = QTableWidgetItem(_norm(r.get("name", "")))
                    self.table.setItem(i, self.COL_IDX_NAME, it_name)

                    it_cat = QTableWidgetItem(_norm(r.get("category", "")))
                    self.table.setItem(i, self.COL_IDX_CAT, it_cat)

                    st_raw = _norm(r.get("status", ""))
                    it_status = QTableWidgetItem(st_raw)
                    self._apply_status_cell_style(it_status, st_raw)
                    self.table.setItem(i, self.COL_IDX_STATUS, it_status)

                    self.table.setItem(i, self.COL_IDX_HOLDER, QTableWidgetItem(_norm(r.get("current_holder", ""))))
                    self.table.setItem(i, self.COL_IDX_LOC, QTableWidgetItem(_norm(r.get("location", ""))))

                    raw_upd = r.get("updated_at", "") or ""
                    try:
                        disp_upd = fmt_dt_sr(raw_upd)
                    except Exception:
                        disp_upd = _norm(raw_upd)
                    dt_sort = _safe_dt_sort_value(raw_upd)
                    it_upd = SortableItem(str(disp_upd), dt_sort)
                    if raw_upd:
                        it_upd.setToolTip(_norm(raw_upd))
                    self.table.setItem(i, self.COL_IDX_UPD, it_upd)

            finally:
                self.table.blockSignals(False)
                self.table.setUpdatesEnabled(True)

        except Exception as e:
            try:
                self.logger.exception("AssetsPage.load_assets failed: %s", e)
            except Exception:
                pass
            QMessageBox.critical(self, "Greška", f"Ne mogu da učitam sredstva.\n\n{e}")
            return
        finally:
            try:
                self.table.setSortingEnabled(was_sorting)
            except Exception:
                pass
            try:
                QApplication.restoreOverrideCursor()
            except Exception:
                pass
            self._loading = False

        # primeni user column prefs (width/visibility/order)
        try:
            self._apply_cols_assets()
        except Exception:
            pass

        # vrati sort (ako je bio aktivan) posle refresha, pa renumber
        try:
            if was_sorting and prev_sort_col >= 0:
                self.table.sortItems(prev_sort_col, prev_sort_order)
        except Exception:
            pass

        self._renumber_view_rows()

        # restore selection by UID if possible
        if selected_uid_before:
            for r in range(self.table.rowCount()):
                it = self.table.item(r, self.COL_IDX_UID)
                if it and it.text().strip() == selected_uid_before:
                    self.table.setCurrentCell(r, self.COL_IDX_UID)
                    break

        self._sync_buttons()
        self._on_selection_changed()

    # -------------------- actions --------------------
    def new_asset(self) -> None:
        if not _can(PERM_ASSETS_CREATE):
            QMessageBox.warning(self, "Zabranjeno", "Nemaš pravo: assets.create.")
            return

        can_any_view = _can(PERM_ASSETS_VIEW) or _can(PERM_ASSETS_MY_VIEW) or _can(PERM_ASSETS_METRO_VIEW)
        if not can_any_view:
            QMessageBox.warning(
                self,
                "Zabranjeno",
                "Novo sredstvo traži i pravo prikaza (assets.view ili assets.my.view ili assets.metrology.view).",
            )
            return

        dlg = NewAssetDialog(self)
        if dlg.exec() != QDialog.Accepted:
            return

        v = dlg.values() or {}

        assignee = _norm(v.get("assignee", ""))
        assign_note = _norm(v.get("assign_note", ""))
        location = _norm(v.get("location", ""))

        status = _norm(v.get("status", "active")).lower() or "active"
        if assignee:
            status = "on_loan"

        nom = _norm(
            v.get("nomenclature_number", "")
            or v.get("nomenclature_no", "")
            or v.get("nomenklaturni_broj", "")
        )

        try:
            kwargs = dict(
                actor=_actor_name(),
                name=v.get("name", ""),
                category=v.get("category", ""),
                toc_number=v.get("toc_number", ""),
                nomenclature_number=nom,
                serial_number=v.get("serial_number", ""),
                location=location,
                status=status,
                sector=v.get("sector", ""),
                is_metrology=int(v.get("is_metrology", 0) or 0),
                source="ui_new_asset",
            )

            # kompatibilnost sa starim servis potpisima
            try:
                uid = create_asset(**kwargs)
            except TypeError:
                kwargs.pop("nomenclature_number", None)
                kwargs["nomenclature_no"] = nom
                try:
                    uid = create_asset(**kwargs)
                except TypeError:
                    kwargs.pop("nomenclature_no", None)
                    uid = create_asset(**kwargs)

            if assignee:
                try:
                    note = "Auto-zaduženje pri kreiranju sredstva"
                    if assign_note:
                        note = f"{note} — {assign_note}"
                    _try_create_assignment_after_create(
                        asset_uid=uid,
                        to_holder=assignee,
                        to_location=location,
                        note=note,
                    )
                except Exception as e_assign:
                    QMessageBox.information(
                        self,
                        "Info",
                        "Sredstvo je kreirano, ali zaduženje nije uspelo.\n\n"
                        f"Razlog: {e_assign}\n\n"
                        "Možeš naknadno da uradiš zaduženje kroz predviđeni modul/akciju.",
                    )

            QMessageBox.information(self, "OK", f"Kreirano sredstvo:\n{uid}")
            self.request_reload()

        except Exception as e:
            try:
                self.logger.exception("AssetsPage.new_asset failed: %s", e)
            except Exception:
                pass
            QMessageBox.critical(self, "Greška", f"Ne mogu da kreiram sredstvo.\n\n{e}")

    def open_selected_detail(self) -> None:
        row = self._current_row_any()
        if row < 0:
            QMessageBox.information(self, "Info", "Prvo izaberi red/ćeliju u tabeli.")
            return
        self.open_detail(row, 0)

    def open_detail(self, row: int, col: int) -> None:
        _ = col
        uid_item = self.table.item(row, self.COL_IDX_UID)
        if not uid_item:
            return
        asset_uid = uid_item.text().strip()
        if not asset_uid:
            return

        try:
            dlg = AssetDetailDialog(asset_uid, self)
            dlg.exec()
        except Exception as e:
            QMessageBox.critical(self, "Greška", f"Ne mogu da otvorim detalje.\n\n{e}")
            return

        self.request_reload()

# (FILENAME: ui/assets_page.py - END)  [PART 3/3]
# END FILENAME: ui/assets_page.py